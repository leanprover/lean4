[{"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw":
    "/-!\n# Applicative Functors\n\nBuilding on [Functors](functors.lean.md) is the [Applicative\nFunctor](https://en.wikipedia.org/wiki/Applicative_functor). For simplicity, you can refer to these\nsimply as \"Applicatives\". These are a little tricker than functors, but still simpler than monads.\nLet's see how they work!\n\n## What is an Applicative Functor?\n\nAn applicative functor defines a default or \"base\" construction for an object and allows\nfunction application to be chained across multiple instances of the structure. All applicative\nfunctors are functors, meaning they must also support the \"map\" operation.\n\n## How are Applicatives represented in Lean?\n\nAn [applicative functor](https://en.wikipedia.org/wiki/Applicative_functor) is an intermediate\nstructure between `Functor` and `Monad`. It mainly consists of two operations:\n\n* `pure : α → F α`\n* `seq : F (α → β) → F α → F β` (written as `<*>`)\n\nThe `pure` operator specifies how you can wrap a normal object `α` into an instance of this structure `F α`.\nThis is the \"default\" mechanism mentioned above.\n\nThe `seq` operator allows you to chain operations by wrapping a function in a structure. The name\n\"applicative\" comes from the fact that you \"apply\" functions from within the structure, rather than\nsimply from outside the structure, as was the case with `Functor.map`.\n\nApplicative in Lean is built on some helper type classes, `Functor`, `Pure` and `Seq`:\n\n-/\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "namespace",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " hidden -- hidden\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "class",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "(Type u → Type v) → Type (max (u + 1) v)",
     "name": "Applicative",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Applicative",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type u → Type v", "name": "f", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "f",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type (u + 1)", "name": "Type u", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Type u",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type (v + 1)", "name": "Type v", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Type v",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "extends",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "(Type u → Type v) → Type (max (u + 1) v)",
     "name": "Functor",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Functor",
    "link": null,
    "docstring":
    "In functional programming, a \"functor\" is a function on types `F : Type u → Type v`\nequipped with an operator called `map` or `<$>` such that if `f : α → β` then\n`map f : F α → F β`, so `f <$> x : F β` if `x : F α`. This corresponds to the\ncategory-theory notion of [functor](https://en.wikipedia.org/wiki/Functor) in\nthe special case where the category is the category of types and functions\nbetween them, except that this class supplies only the operations and not the\nlaws (see `LawfulFunctor`).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type u → Type v", "name": "f", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "f",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "(Type u → Type v) → Type (max (u + 1) v)",
     "name": "Pure",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Pure",
    "link": null,
    "docstring":
    "The typeclass which supplies the `pure` function. See `Monad`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type u → Type v", "name": "f", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "f",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "(Type u → Type v) → Type (max (u + 1) v)",
     "name": "Seq",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Seq",
    "link": null,
    "docstring":
    "The typeclass which supplies the `<*>` \"seq\" function. See `Applicative`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type u → Type v", "name": "f", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "f",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "(Type u → Type v) → Type (max (u + 1) v)",
     "name": "SeqLeft",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "SeqLeft",
    "link": null,
    "docstring":
    "The typeclass which supplies the `<*` \"seqLeft\" function. See `Applicative`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type u → Type v", "name": "f", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "f",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "(Type u → Type v) → Type (max (u + 1) v)",
     "name": "SeqRight",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "SeqRight",
    "link": null,
    "docstring":
    "The typeclass which supplies the `<*` \"seqRight\" function. See `Applicative`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type u → Type v", "name": "f", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "f",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "where",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  map      := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "fun",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "α✝ → β✝", "name": "x", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "x",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "f α✝", "name": "y", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "y",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type":
     "{f : Type u → Type v} → [self : Seq f] → {α β : Type u} → f (α → β) → (Unit → f α) → f β",
     "name": "Seq.seq",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Seq.seq",
    "link": null,
    "docstring":
    "If `mf : F (α → β)` and `mx : F α`, then `mf <*> mx : F β`.\n  In a monad this is the same as `do let f ← mf; x ← mx; pure (f x)`:\n  it evaluates first the function, then the argument, and applies one to the other.\n\n  To avoid surprising evaluation semantics, `mx` is taken \"lazily\", using a\n  `Unit → f α` function. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α : Type u} → α → f α", "name": "pure", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "pure",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "α✝ → β✝", "name": "x", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "x",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "fun",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Unit", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "f α✝", "name": "y", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "y",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  seqLeft  := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "fun",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "f α✝", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Unit → f β✝", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type":
     "{f : Type u → Type v} → [self : Seq f] → {α β : Type u} → f (α → β) → (Unit → f α) → f β",
     "name": "Seq.seq",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Seq.seq",
    "link": null,
    "docstring":
    "If `mf : F (α → β)` and `mx : F α`, then `mf <*> mx : F β`.\n  In a monad this is the same as `do let f ← mf; x ← mx; pure (f x)`:\n  it evaluates first the function, then the argument, and applies one to the other.\n\n  To avoid surprising evaluation semantics, `mx` is taken \"lazily\", using a\n  `Unit → f α` function. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type":
     "{f : Type u → Type v} → [self : Functor f] → {α β : Type u} → (α → β) → f α → f β",
     "name": "Functor.map",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Functor.map",
    "link": null,
    "docstring": "If `f : α → β` and `x : F α` then `f <$> x : F β`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α : Type u} → (β : Type u) → α → β → α",
     "name": "Function.const",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Function.const",
    "link": null,
    "docstring":
    "The constant function. If `a : α`, then `Function.const β a : β → α` is the\n\"constant function with value `a`\", that is, `Function.const β a b = a`.\n```\nexample (b : Bool) : Function.const Bool 10 b = 10 :=\n  rfl\n\n#check Function.const Bool 10\n-- Bool → Nat\n```\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type u", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "f α✝", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Unit → f β✝", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  seqRight := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "fun",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "f α✝", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Unit → f β✝", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type":
     "{f : Type u → Type v} → [self : Seq f] → {α β : Type u} → f (α → β) → (Unit → f α) → f β",
     "name": "Seq.seq",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Seq.seq",
    "link": null,
    "docstring":
    "If `mf : F (α → β)` and `mx : F α`, then `mf <*> mx : F β`.\n  In a monad this is the same as `do let f ← mf; x ← mx; pure (f x)`:\n  it evaluates first the function, then the argument, and applies one to the other.\n\n  To avoid surprising evaluation semantics, `mx` is taken \"lazily\", using a\n  `Unit → f α` function. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type":
     "{f : Type u → Type v} → [self : Functor f] → {α β : Type u} → (α → β) → f α → f β",
     "name": "Functor.map",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Functor.map",
    "link": null,
    "docstring": "If `f : α → β` and `x : F α` then `f <$> x : F β`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α : Type u} → (β : Type u) → α → β → α",
     "name": "Function.const",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Function.const",
    "link": null,
    "docstring":
    "The constant function. If `a : α`, then `Function.const β a : β → α` is the\n\"constant function with value `a`\", that is, `Function.const β a b = a`.\n```\nexample (b : Bool) : Function.const Bool 10 b = 10 :=\n  rfl\n\n#check Function.const Bool 10\n-- Bool → Nat\n```\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type u", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α : Type u} → α → α", "name": "id", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "id",
    "link": null,
    "docstring":
    "The identity function. `id` takes an implicit argument `α : Sort u`\n(a type in any universe), and an argument `a : α`, and returns `a`.\n\nAlthough this may look like a useless function, one application of the identity\nfunction is to explicitly put a type on an expression. If `e` has type `T`,\nand `T'` is definitionally equal to `T`, then `@id T' e` typechecks, and lean\nknows that this expression has type `T'` rather than `T`. This can make a\ndifference for typeclass inference, since `T` and `T'` may have different\ntypeclass instances on them. `show T' from e` is sugar for an `@id T' e`\nexpression.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "f α✝", "name": "a", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "a",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Unit → f β✝", "name": "b", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "b",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "end",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw":
    " hidden -- hidden\n/-!\nNotice that as with `Functor` it is also a type transformer `(f : Type u → Type v)` and notice the\n`extends Functor f` is ensuring the base `Functor` also performs that same type transformation.\n\nAs stated above, all applicatives are then functors. This means you can assume that `map` already\nexists for all these types.\n\nThe `Pure` base type class is a very simple type class that supplies the `pure` function.\n\n-/\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "namespace",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " hidden -- hidden\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "class",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{f : Type u → Type v} → ({α : Type u} → α → f α) → Pure f",
     "name": "Pure",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Pure",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type u → Type v", "name": "f", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "f",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type (u + 1)", "name": "Type u", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Type u",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type (v + 1)", "name": "Type v", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Type v",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "where",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n   ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{f : Type u → Type v} → [self : Pure f] → {α : Type u} → α → f α",
     "name": "pure",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "pure",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type u", "name": "α", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "α",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type (u + 1)", "name": "Type u", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Type u",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type u", "name": "α", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "α",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type u → Type v", "name": "f", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "f",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type u", "name": "α", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "α",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "end",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw":
    " hidden -- hidden\n/-!\n\nYou can think of it as lifing the result of a pure value to some monadic type. The simplest example\nof `pure` is the `Option` type:\n\n-/\n",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [{"contents": "some 10\n", "_type": "message"}],
  "goals": [],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "#eval",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{f : Type → Type} → [self : Pure f] → {α : Type} → α → f α",
     "name": "pure",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "pure",
    "link": null,
    "docstring":
    "If `a : α`, then `pure a : f α` represents a monadic action that does\nnothing and returns `a`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "10", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "10",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type → Type", "name": "Option", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Option",
    "link": null,
    "docstring":
    "`Option α` is the type of values which are either `some a` for some `a : α`,\nor `none`. In functional programming languages, this type is used to represent\nthe possibility of failure, or sometimes nullability.\n\nFor example, the function `HashMap.find? : HashMap α β → α → Option β` looks up\na specified key `a : α` inside the map. Because we do not know in advance\nwhether the key is actually in the map, the return type is `Option β`, where\n`none` means the value was not in the map, and `some b` means that the value\nwas found and `b` is the value retrieved.\n\nTo extract a value from an `Option α`, we use pattern matching:\n```\ndef map (f : α → β) (x : Option α) : Option β :=\n  match x with\n  | some a => some (f a)\n  | none => none\n```\nWe can also use `if let` to pattern match on `Option` and get the value\nin the branch:\n```\ndef map (f : α → β) (x : Option α) : Option β :=\n  if let some a := x then\n    some (f a)\n  else\n    none\n```\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw":
    ")  -- some 10\n/-!\n\nHere we used the `Option` implementation of `pure` to wrap the `Nat 10` value in an `Option Nat`\ntype resulting in the value `some 10`, and in fact if you look at the Monad instance of `Option` , you\nwill see that `pure` is indeed implemented using `Option.some`:\n\n-/\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "Monad Option", "name": "instance", "_type": "typeinfo"},
    "semanticType": "Keyword",
    "raw": "instance",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "(Type u_1 → Type u_1) → Type (u_1 + 1)",
     "name": "Monad",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Monad",
    "link": null,
    "docstring":
    "A [monad](https://en.wikipedia.org/wiki/Monad_(functional_programming)) is a\nstructure which abstracts the concept of sequential control flow.\nIt mainly consists of two operations:\n\n* `pure : α → F α`\n* `bind : F α → (α → F β) → F β` (written as `>>=`)\n\nLike many functional programming languages, Lean makes extensive use of monads\nfor structuring programs. In particular, the `do` notation is a very powerful\nsyntax over monad operations, and it depends on a `Monad` instance.\n\nSee [the `do` notation](https://leanprover.github.io/lean4/doc/do.html)\nchapter of the manual for details.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "Type u_1 → Type u_1", "name": "Option", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Option",
    "link": null,
    "docstring":
    "`Option α` is the type of values which are either `some a` for some `a : α`,\nor `none`. In functional programming languages, this type is used to represent\nthe possibility of failure, or sometimes nullability.\n\nFor example, the function `HashMap.find? : HashMap α β → α → Option β` looks up\na specified key `a : α` inside the map. Because we do not know in advance\nwhether the key is actually in the map, the return type is `Option β`, where\n`none` means the value was not in the map, and `some b` means that the value\nwas found and `b` is the value retrieved.\n\nTo extract a value from an `Option α`, we use pattern matching:\n```\ndef map (f : α → β) (x : Option α) : Option β :=\n  match x with\n  | some a => some (f a)\n  | none => none\n```\nWe can also use `if let` to pattern match on `Option` and get the value\nin the branch:\n```\ndef map (f : α → β) (x : Option α) : Option β :=\n  if let some a := x then\n    some (f a)\n  else\n    none\n```\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "where",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n    ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "pure",
    "link": null,
    "docstring":
    "If `a : α`, then `pure a : f α` represents a monadic action that does\nnothing and returns `a`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α : Type u_1} → α → Option α",
     "name": "Option.some",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Option.some",
    "link": null,
    "docstring": "Some value of type `α`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw":
    "\n/-!\n\nThe `Seq` type class is also a simple type class that provides the `seq` operator which can\nalso be written using the special syntax `<*>`.\n\n-/\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "namespace",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " hidden -- hidden\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "class",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type":
     "{f : Type u → Type v} → ({α β : Type u} → f (α → β) → (Unit → f α) → f β) → Seq f",
     "name": "Seq",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Seq",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type u → Type v", "name": "f", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "f",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type (u + 1)", "name": "Type u", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Type u",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type (v + 1)", "name": "Type v", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Type v",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "Type ((max (u + 1) v) + 1)",
     "name": "Type (max (u+1) v)",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Type (max (u+1) v)",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "where",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type":
     "{f : Type u → Type v} → [self : Seq f] → {α β : Type u} → f (α → β) → (Unit → f α) → f β",
     "name": "seq",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "seq",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : {",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type u", "name": "α", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "α",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type u", "name": "β", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "β",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type (u + 1)", "name": "Type u", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Type u",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "} → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type u → Type v", "name": "f", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "f",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type u", "name": "α", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "α",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type u", "name": "β", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "β",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") → (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Unit", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Unit",
    "link": null,
    "docstring":
    "The unit type, the canonical type with one element, named `unit` or `()`.\nIn other words, it describes only a single value, which consists of said constructor applied\nto no arguments whatsoever.\nThe `Unit` type is similar to `void` in languages derived from C.\n\n`Unit` is actually defined as `PUnit.{0}` where `PUnit` is the universe\npolymorphic version. The `Unit` should be preferred over `PUnit` where possible to avoid\nunnecessary universe parameters.\n\nIn functional programming, `Unit` is the return type of things that \"return\nnothing\", since a type with one element conveys no additional information.\nWhen programming with monads, the type `m Unit` represents an action that has\nsome side effects but does not return a value, while `m α` would be an action\nthat has side effects and returns a value of type `α`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type u → Type v", "name": "f", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "f",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type u", "name": "α", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "α",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type u → Type v", "name": "f", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "f",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type u", "name": "β", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "β",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "end",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw":
    " hidden -- hidden\n/-!\n\n\n## Basic Applicative Examples\n\nMany of the basic functors also have instances of `Applicative`.\nFor example, `Option` is also `Applicative`.\n\nSo let's take a look and what the `seq` operator can do.  Suppose you want to multiply two `Option Nat`\nobjects.  Your first attempt might be this:\n\n-/\n",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [{"contents": "some 4 * some 5 : ?m.637", "_type": "message"}],
  "goals": [],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "#check_failure",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"messages":
  [{"contents": "some 4 * some 5 : ?m.637", "_type": "message"},
   {"contents":
    "Warning: failed to synthesize instance\n  HMul (Option Nat) (Option Nat) ?m.637",
    "_type": "message"}],
  "goals": [],
  "contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": "(",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α : Type} → α → Option α", "name": "some", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "some",
    "link": null,
    "docstring": "Some value of type `α`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "4", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "4",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") * (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α : Type} → α → Option α", "name": "some", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "some",
    "link": null,
    "docstring": "Some value of type `α`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "5", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "5",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw":
    "      -- failed to synthesize instance\n/-!\n\nYou then might wonder how to use the `Functor.map` to solve this since you could do these before:\n\n-/\n",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [{"contents": "some 20\n", "_type": "message"}],
  "goals": [],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "#eval",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α : Type} → α → Option α", "name": "some", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "some",
    "link": null,
    "docstring": "Some value of type `α`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "4", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "4",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ").",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α β : Type} → (α → β) → Option α → Option β",
     "name": "map",
     "_type": "typeinfo"},
    "semanticType": "Name.Attribute",
    "raw": "map",
    "link": null,
    "docstring":
    "Map a function over an `Option` by applying the function to the contained\nvalue if present.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "fun",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "x", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "x",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "x", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "x",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "5", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "5",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")  -- some 20\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [{"contents": "some 20\n", "_type": "message"}],
  "goals": [],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "#eval",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α : Type} → α → Option α", "name": "some", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "some",
    "link": null,
    "docstring": "Some value of type `α`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "4", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "4",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ").",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α β : Type} → (α → β) → Option α → Option β",
     "name": "map",
     "_type": "typeinfo"},
    "semanticType": "Name.Attribute",
    "raw": "map",
    "link": null,
    "docstring":
    "Map a function over an `Option` by applying the function to the contained\nvalue if present.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (· * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "5", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "5",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")  -- some 20\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [{"contents": "some 20\n", "_type": "message"}],
  "goals": [],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "#eval",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " (· * ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "5", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "5",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") <$> (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α : Type} → α → Option α", "name": "some", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "some",
    "link": null,
    "docstring": "Some value of type `α`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "4", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "4",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw":
    ")   -- some 20\n/-!\n\nRemember that `<$>` is the infix notation for `Functor.map`.\n\nThe functor `map` operation can apply a multiplication to the value in the `Option` and then lift the\nresult back up to become a new `Option` , but this isn't what you need here.\n\nThe `Seq.seq` operator `<*>` can help since it can apply a function to the items inside a\ncontainer and then lift the result back up to the desired type, namely `Option` .\n\nThere are two ways to do this:\n\n-/\n",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [{"contents": "some 20\n", "_type": "message"}],
  "goals": [],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "#eval",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{f : Type → Type} → [self : Pure f] → {α : Type} → α → f α",
     "name": "pure",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "pure",
    "link": null,
    "docstring":
    "If `a : α`, then `pure a : f α` represents a monadic action that does\nnothing and returns `a`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "Nat → Nat → Nat", "name": "(.*.)", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "(.*.)",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " <*> ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α : Type} → α → Option α", "name": "some", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "some",
    "link": null,
    "docstring": "Some value of type `α`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "4", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "4",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " <*> ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α : Type} → α → Option α", "name": "some", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "some",
    "link": null,
    "docstring": "Some value of type `α`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "5", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "5",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " -- some 20\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [{"contents": "some 20\n", "_type": "message"}],
  "goals": [],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "#eval",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "Nat → Nat → Nat", "name": "(.*.)", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "(.*.)",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " <$> ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α : Type} → α → Option α", "name": "some", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "some",
    "link": null,
    "docstring": "Some value of type `α`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "4", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "4",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " <*> ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α : Type} → α → Option α", "name": "some", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "some",
    "link": null,
    "docstring": "Some value of type `α`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "5", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "5",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw":
    " -- some 20\n/-!\n\nIn the first way, we start off by wrapping the function in an applicative using pure. Then we apply\nthis to the first `Option` , and again to the second `Option`  in a chain of operations.  So  you can see\nhow `Seq.seq` can be chained in fact, `Seq.seq` is really all about chaining of operations.\n\nBut in this case there is a simpler way.  In the second way, you can see that \"applying\" a single\nfunction to a container is the same as using `Functor.map`. So you use `<$>` to \"transform\" the first\noption into an `Option` containing a function, and then apply this function over the second value.\n\nNow if either side is `none`, the result is `none`, as expected, and in this case the\n`seq` operator was able to eliminate the multiplication:\n\n-/\n",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [{"contents": "none\n", "_type": "message"}],
  "goals": [],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "#eval",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "Nat → Nat → Nat", "name": "(.*.)", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "(.*.)",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " <$> ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α : Type} → Option α", "name": "none", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "none",
    "link": null,
    "docstring": "No value. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " <*> ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α : Type} → α → Option α", "name": "some", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "some",
    "link": null,
    "docstring": "Some value of type `α`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "5", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "5",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "  -- none\n",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [{"contents": "none\n", "_type": "message"}],
  "goals": [],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "#eval",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "Nat → Nat → Nat", "name": "(.*.)", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "(.*.)",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " <$> ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α : Type} → α → Option α", "name": "some", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "some",
    "link": null,
    "docstring": "Some value of type `α`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "4", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "4",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " <*> ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α : Type} → Option α", "name": "none", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "none",
    "link": null,
    "docstring": "No value. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw":
    "  -- none\n/-!\n\nFor a more interesting example, let's make `List` an applicative by adding the following\ndefinition:\n\n-/\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "Applicative List", "name": "instance", "_type": "typeinfo"},
    "semanticType": "Keyword",
    "raw": "instance",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "(Type u_1 → Type u_1) → Type (u_1 + 1)",
     "name": "Applicative",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Applicative",
    "link": null,
    "docstring":
    "An [applicative functor](https://en.wikipedia.org/wiki/Applicative_functor) is\nan intermediate structure between `Functor` and `Monad`. It mainly consists of\ntwo operations:\n\n* `pure : α → F α`\n* `seq : F (α → β) → F α → F β` (written as `<*>`)\n\nThe `seq` operator gives a notion of evaluation order to the effects, where\nthe first argument is executed before the second, but unlike a monad the results\nof earlier computations cannot be used to define later actions.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "Type u_1 → Type u_1", "name": "List", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "List",
    "link": null,
    "docstring":
    "`List α` is the type of ordered lists with elements of type `α`.\nIt is implemented as a linked list.\n\n`List α` is isomorphic to `Array α`, but they are useful for different things:\n* `List α` is easier for reasoning, and\n  `Array α` is modeled as a wrapper around `List α`\n* `List α` works well as a persistent data structure, when many copies of the\n  tail are shared. When the value is not shared, `Array α` will have better\n  performance because it can do destructive updates.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "where",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "pure",
    "link": null,
    "docstring":
    "If `a : α`, then `pure a : f α` represents a monadic action that does\nnothing and returns `a`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α : Type u_1} → α → List α",
     "name": "List.pure",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "List.pure",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "seq",
    "link": null,
    "docstring":
    "If `mf : F (α → β)` and `mx : F α`, then `mf <*> mx : F β`.\n  In a monad this is the same as `do let f ← mf; x ← mx; pure (f x)`:\n  it evaluates first the function, then the argument, and applies one to the other.\n\n  To avoid surprising evaluation semantics, `mx` is taken \"lazily\", using a\n  `Unit → f α` function. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "List (α✝ → β✝)", "name": "f", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "f",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Unit → List α✝", "name": "x", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "x",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α β : Type u_1} → List α → (α → List β) → List β",
     "name": "List.bind",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "List.bind",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "List (α✝ → β✝)", "name": "f", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "f",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "fun",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "α✝ → β✝", "name": "y", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "y",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type":
     "{f : Type u_1 → Type u_1} → [self : Functor f] → {α β : Type u_1} → (α → β) → f α → f β",
     "name": "Functor.map",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Functor.map",
    "link": null,
    "docstring": "If `f : α → β` and `x : F α` then `f <$> x : F β`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "α✝ → β✝", "name": "y", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "y",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Unit → List α✝", "name": "x", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "x",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Unit", "name": "()", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "()",
    "link": null,
    "docstring":
    "`Unit.unit : Unit` is the canonical element of the unit type.\nIt can also be written as `()`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw":
    ")\n/-!\n\nNotice you can now sequence a _list_ of functions and a _list_ of items.\nThe trivial case of sequencing a singleton list is in fact the same as `map`, as you saw\nearlier with the `Option`  examples:\n\n-/\n",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [{"contents": "[6, 8]\n", "_type": "message"}],
  "goals": [],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "#eval",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " [ (·+",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "2", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "2",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")] <*> [",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "4", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "4",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "6", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "6",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "] -- [6, 8]\n",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [{"contents": "[6, 8]\n", "_type": "message"}],
  "goals": [],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "#eval",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " (·+",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "2", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "2",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") <$> [",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "4", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "4",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ",",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "6", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "6",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw":
    "]    -- [6, 8]\n/-!\n\nBut now with list it is easier to show the difference when you do this:\n\n-/\n",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [{"contents": "[6, 8, 12, 18]\n", "_type": "message"}],
  "goals": [],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "#eval",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " [(·+",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "2", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "2",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "), (· *",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "3", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "3",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ")] <*> [",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "4", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "4",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "6", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "6",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw":
    "] -- [6, 8, 12, 18]\n/-!\n\nWhy did this produce 4 values?  The reason is because `<*>` applies _every_ function to _every_\nvalue in a pairwise manner.  This makes sequence really convenient for solving certain problems. For\nexample, how do you get the pairwise combinations of all values from two lists?\n\n-/\n",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages":
  [{"contents":
    "[(1, 4), (1, 5), (1, 6), (2, 4), (2, 5), (2, 6), (3, 4), (3, 5), (3, 6)]\n",
    "_type": "message"}],
  "goals": [],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "#eval",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α β : Type} → α → β → α × β",
     "name": "Prod.mk",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Prod.mk",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " <$> [",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "1", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "1",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "2", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "2",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "3", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "3",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "] <*> [",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "4", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "4",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "5", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "5",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "6", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "6",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw":
    "]\n-- [(1, 4), (1, 5), (1, 6), (2, 4), (2, 5), (2, 6), (3, 4), (3, 5), (3, 6)]\n/-!\n\nHow do you get the sum of these pairwise values?\n-/\n",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages":
  [{"contents": "[5, 6, 7, 6, 7, 8, 7, 8, 9]\n", "_type": "message"}],
  "goals": [],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "#eval",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "Nat → Nat → Nat", "name": "(·+·)", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "(·+·)",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " <$> [",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "1", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "1",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "2", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "2",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "3", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "3",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "] <*> [",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "4", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "4",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "5", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "5",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "6", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "6",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw":
    "]\n-- [5, 6, 7, 6, 7, 8, 7, 8, 9]\n/-!\n\nHere you can use `<$>` to \"transform\" each element of the first list into a function, and then apply\nthese functions over the second list.\n\nIf you have 3 lists, and want to find all combinations of 3 values across those lists you\nwould need helper function that can create a tuple out of 3 values, and Lean provides a\nvery convenient syntax for that `(·,·,·)`:\n\n-/\n",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages":
  [{"contents":
    "[(1, 3, 5), (1, 3, 6), (1, 4, 5), (1, 4, 6), (2, 3, 5), (2, 3, 6), (2, 4, 5), (2, 4, 6)]\n",
    "_type": "message"}],
  "goals": [],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "#eval",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "Nat → Nat → Nat → Nat × Nat × Nat",
     "name": "(·,·,·)",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "(·,·,·)",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " <$> [",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "1", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "1",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "2", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "2",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "] <*> [",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "3", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "3",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "4", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "4",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "] <*> [",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "5", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "5",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "6", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "6",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw":
    "]\n-- [(1, 3, 5), (1, 3, 6), (1, 4, 5), (1, 4, 6), (2, 3, 5), (2, 3, 6), (2, 4, 5), (2, 4, 6)]\n/-!\n\nAnd you could sum these combinations if you first define a sum function that takes three inputs and\nthen you could chain apply this over the three lists.  Again lean can create such a function\nwith the expression `(·+·+·)`:\n\n-/\n",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages":
  [{"contents": "[9, 10, 10, 11, 10, 11, 11, 12]\n", "_type": "message"}],
  "goals": [],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "#eval",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "Nat → Nat → Nat → Nat", "name": "(·+·+·)", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "(·+·+·)",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " <$> [",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "1", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "1",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "2", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "2",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "] <*> [",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "3", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "3",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "4", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "4",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "] <*> [",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "5", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "5",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "6", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "6",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw":
    "]\n-- [9, 10, 10, 11, 10, 11, 11, 12]\n/-!\n\nAnd indeed each sum here matches the expected values if you manually sum the triples we\nshow above.\n\n**Side note:** there is another way to combine lists with a function that does not do the pairwise\ncombinatorics, it is called `List.zipWith`:\n\n-/\n",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [{"contents": "[5, 7, 9]\n", "_type": "message"}],
  "goals": [],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "#eval",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α β γ : Type} → (α → β → γ) → List α → List β → List γ",
     "name": "List.zipWith",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "List.zipWith",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "Nat → Nat → Nat", "name": "(·+·)", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "(·+·)",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "1", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "1",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "2", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "2",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "3", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "3",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "] [",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "4", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "4",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "5", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "5",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "6", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "6",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw":
    "]\n-- [5, 7, 9]\n/-!\n\nAnd there is a helper function named `List.zip` that calls `zipWith` using the function `Prod.mk`\nso you get a nice zipped list like this:\n\n-/\n",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [{"contents": "[(1, 4), (2, 5), (3, 6)]\n", "_type": "message"}],
  "goals": [],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "#eval",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α β : Type} → List α → List β → List (α × β)",
     "name": "List.zip",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "List.zip",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "1", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "1",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "2", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "2",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "3", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "3",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "] [",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "4", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "4",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "5", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "5",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "6", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "6",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw":
    "]\n-- [(1, 4), (2, 5), (3, 6)]\n/-!\n\nAnd of couse, as you would expect, there is an `unzip` also:\n\n-/\n",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [{"contents": "([1, 2, 3], [4, 5, 6])\n", "_type": "message"}],
  "goals": [],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "#eval",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α β : Type} → List (α × β) → List α × List β",
     "name": "List.unzip",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "List.unzip",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α β : Type} → List α → List β → List (α × β)",
     "name": "List.zip",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "List.zip",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " [",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "1", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "1",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "2", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "2",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "3", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "3",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "] [",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "4", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "4",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "5", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "5",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "6", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "6",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw":
    "])\n-- ([1, 2, 3], [4, 5, 6])\n/-!\n\n## Example: A Functor that is not Applicative\n\nFrom the chapter on [functors](functors.lean.md) you might remember this example of `LivingSpace`\nthat had a `Functor` instance:\n\n-/\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "structure",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "Type → Type", "name": "LivingSpace", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "LivingSpace",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "α", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "α",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type 1", "name": "Type", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Type",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "where",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α : Type} → LivingSpace α → α",
     "name": "totalSize",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "totalSize",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "α", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "α",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α : Type} → LivingSpace α → Nat",
     "name": "numBedrooms",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "numBedrooms",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Nat", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Nat",
    "link": null,
    "docstring":
    "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α : Type} → LivingSpace α → α",
     "name": "masterBedroomSize",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "masterBedroomSize",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "α", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "α",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α : Type} → LivingSpace α → α",
     "name": "livingRoomSize",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "livingRoomSize",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "α", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "α",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α : Type} → LivingSpace α → α",
     "name": "kitchenSize",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "kitchenSize",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "α", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "α",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "deriving",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "Type u → Type u", "name": "Repr", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Repr",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ", ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type u → Type u", "name": "BEq", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "BEq",
    "link": null,
    "docstring":
    "`BEq α` is a typeclass for supplying a boolean-valued equality relation on\n`α`, notated as `a == b`. Unlike `DecidableEq α` (which uses `a = b`), this\nis `Bool` valued instead of `Prop` valued, and it also does not have any\naxioms like being reflexive or agreeing with `=`. It is mainly intended for\nprogramming applications. See `LawfulBEq` for a version that requires that\n`==` and `=` coincide.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "def",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α β : Type} → (α → β) → LivingSpace α → LivingSpace β",
     "name": "LivingSpace.map",
     "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "LivingSpace.map",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "α → β", "name": "f", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "f",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "α", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "α",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " → ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "β", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "β",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "LivingSpace α", "name": "s", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "s",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "Type → Type", "name": "LivingSpace", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "LivingSpace",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "α", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "α",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "Type → Type", "name": "LivingSpace", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "LivingSpace",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "β", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "β",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " :=\n  { totalSize := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "α → β", "name": "f", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "f",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "LivingSpace α", "name": "s", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "s",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α : Type} → LivingSpace α → α",
     "name": "totalSize",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "totalSize",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n    numBedrooms := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "LivingSpace α", "name": "s", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "s",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α : Type} → LivingSpace α → Nat",
     "name": "numBedrooms",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "numBedrooms",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n    masterBedroomSize := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "α → β", "name": "f", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "f",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "LivingSpace α", "name": "s", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "s",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α : Type} → LivingSpace α → α",
     "name": "masterBedroomSize",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "masterBedroomSize",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n    livingRoomSize := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "α → β", "name": "f", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "f",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "LivingSpace α", "name": "s", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "s",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α : Type} → LivingSpace α → α",
     "name": "livingRoomSize",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "livingRoomSize",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n    kitchenSize := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "α → β", "name": "f", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "f",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "LivingSpace α", "name": "s", "_type": "typeinfo"},
    "semanticType": "Name.Variable",
    "raw": "s",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ".",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α : Type} → LivingSpace α → α",
     "name": "kitchenSize",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "kitchenSize",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " }\n\n",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "Functor LivingSpace", "name": "instance", "_type": "typeinfo"},
    "semanticType": "Keyword",
    "raw": "instance",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "(Type → Type) → Type 1", "name": "Functor", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Functor",
    "link": null,
    "docstring":
    "In functional programming, a \"functor\" is a function on types `F : Type u → Type v`\nequipped with an operator called `map` or `<$>` such that if `f : α → β` then\n`map f : F α → F β`, so `f <$> x : F β` if `x : F α`. This corresponds to the\ncategory-theory notion of [functor](https://en.wikipedia.org/wiki/Functor) in\nthe special case where the category is the category of types and functions\nbetween them, except that this class supplies only the operations and not the\nlaws (see `LawfulFunctor`).\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "Type → Type", "name": "LivingSpace", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "LivingSpace",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "where",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "\n  ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": "map",
    "link": null,
    "docstring": "If `f : α → β` and `x : F α` then `f <$> x : F β`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " := ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α β : Type} → (α → β) → LivingSpace α → LivingSpace β",
     "name": "LivingSpace.map",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "LivingSpace.map",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw":
    "\n/-!\n\nIt wouldn't really make sense to make an `Applicative` instance here. How would you write `pure` in\nthe `Applicative` instance? By taking a single value and plugging it in for total size _and_ the\nmaster bedroom size _and_ the living room size? That wouldn't really make sense. And what would the\nnumBedrooms value be for the default? What would it mean to \"chain\" two of these objects together?\n\nIf you can't answer these questions very well, then it suggests this type isn't really an\nApplicative functor.\n\n## SeqLeft and SeqRight\n\nYou may remember seeing the `SeqLeft` and `SeqRight` base types on `class Applicative` earlier.\nThese provide the `seqLeft` and `seqRight` operations which also have some handy notation\nshorthands `<*` and `*>` repsectively. Where: `x <* y` evaluates `x`, then `y`, and returns the\nresult of `x` and `x *> y` evaluates `x`, then `y`,  and returns the result of `y`.\n\nTo make it easier to remember, notice that it returns that value that the `<*` or `*>` notation is\npointing at.  For example:\n\n-/\n",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [{"contents": "some 2\n", "_type": "message"}],
  "goals": [],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "#eval",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α : Type} → α → Option α", "name": "some", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "some",
    "link": null,
    "docstring": "Some value of type `α`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "1", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "1",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") *> (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α : Type} → α → Option α", "name": "some", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "some",
    "link": null,
    "docstring": "Some value of type `α`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "2", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "2",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") -- Some 2\n",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [{"contents": "some 1\n", "_type": "message"}],
  "goals": [],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "#eval",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α : Type} → α → Option α", "name": "some", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "some",
    "link": null,
    "docstring": "Some value of type `α`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "1", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "1",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") <* (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α : Type} → α → Option α", "name": "some", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "some",
    "link": null,
    "docstring": "Some value of type `α`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "2", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "2",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw":
    ") -- Some 1\n/-!\n\nSo these are a kind of \"discard\" operation.  Run all the actions, but only return the values that you\ncare about. It will be easier to see these in action when you get to full Monads, but they are used\nheavily in the Lean `Parsec` parser combinator library where you will find parsing functions like\nthis one which parses the XML declaration `<?xml version=\"1.0\" encoding='utf-8' standalone=\"yes\">`:\n\n```lean\ndef XMLdecl : Parsec Unit := do\n  skipString \"<?xml\"\n  VersionInfo\n  optional EncodingDecl *> optional SDDecl *> optional S *> skipString \"?>\"\n```\n\nBut you will need to understand full Monads before this will make sense.\n\n## Lazy Evaluation\n\nDiving a bit deeper, (you can skip this and jump to the [Applicative\nLaws](laws.lean.md#what-are-the-applicative-laws) if don't want to dive into this implementation detail right\nnow). But, if you write a simple `Option` example `(.*.) <$> some 4 <*> some 5` that produces `some 20`\nusing `Seq.seq` you will see somthing interesting:\n\n-/\n",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"},
 {"messages": [{"contents": "some 20\n", "_type": "message"}],
  "goals": [],
  "contents":
  [{"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "#eval",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "sentence"},
 {"contents":
  [{"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type":
     "{f : Type → Type} → [self : Seq f] → {α β : Type} → f (α → β) → (Unit → f α) → f β",
     "name": "Seq.seq",
     "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Seq.seq",
    "link": null,
    "docstring":
    "If `mf : F (α → β)` and `mx : F α`, then `mf <*> mx : F β`.\n  In a monad this is the same as `do let f ← mf; x ← mx; pure (f x)`:\n  it evaluates first the function, then the argument, and applies one to the other.\n\n  To avoid surprising evaluation semantics, `mx` is taken \"lazily\", using a\n  `Unit → f α` function. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "Nat → Nat → Nat", "name": "(.*.)", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "(.*.)",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " <$> ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α : Type} → α → Option α", "name": "some", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "some",
    "link": null,
    "docstring": "Some value of type `α`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "4", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "4",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": "Keyword",
    "raw": "fun",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " (",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Unit", "name": "_", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "_",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " : ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Type", "name": "Unit", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "Unit",
    "link": null,
    "docstring":
    "The unit type, the canonical type with one element, named `unit` or `()`.\nIn other words, it describes only a single value, which consists of said constructor applied\nto no arguments whatsoever.\nThe `Unit` type is similar to `void` in languages derived from C.\n\n`Unit` is actually defined as `PUnit.{0}` where `PUnit` is the universe\npolymorphic version. The `Unit` should be preferred over `PUnit` where possible to avoid\nunnecessary universe parameters.\n\nIn functional programming, `Unit` is the return type of things that \"return\nnothing\", since a type with one element conveys no additional information.\nWhen programming with monads, the type `m Unit` represents an action that has\nsome side effects but does not return a value, while `m α` would be an action\nthat has side effects and returns a value of type `α`.\n",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": ") => ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo":
    {"type": "{α : Type} → α → Option α", "name": "some", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "some",
    "link": null,
    "docstring": "Some value of type `α`. ",
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw": " ",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": {"type": "Nat", "name": "5", "_type": "typeinfo"},
    "semanticType": null,
    "raw": "5",
    "link": null,
    "docstring": null,
    "_type": "token"},
   {"typeinfo": null,
    "semanticType": null,
    "raw":
    ") -- some 20\n/-!\n\nThis may look a bit combersome, specifically, why did we need to invent this funny looking function\n`fun (_ : Unit) => (some 5)`?\n\nWell if you take a close look at the type class definition:\n```lean\nclass Seq (f : Type u → Type v) where\n  seq : {α β : Type u} → f (α → β) → (Unit → f α) → f β\n```\n\nYou will see this function defined here: `(Unit → f α)`, this is a function that takes `Unit` as input\nand produces the output of type `f α` where `f` is the container type `Type u -> Type v`, in this example `Option`\nand `α` is the element type `Nat`, so `fun (_ : Unit) => some 5` matches this definition because\nit is taking an input of type Unit and producing `some 5` which is type `Option Nat`.\n\nThe that `seq` is defined this way is because Lean is an eagerly evaluated language\n(call-by-value), you have to use this kind of Unit function whenever you want to explicitly delay\nevaluation and `seq` wants that so it can eliminate unnecessary function evaluations whenever\npossible.\n\nFortunately the `<*>` infix notation hides this from you by creating this wrapper function for you.\nIf you look up the notation using F12 in VS Code you will find it contains `(fun _ : Unit => b)`.\n\nNow to complete this picture you will find the default implementation of `seq` on the Lean `Monad`\ntype class:\n\n```lean\nclass Monad (m : Type u → Type v) extends Applicative m, Bind m where\n  seq      f x := bind f fun y => Functor.map y (x ())\n```\n\nNotice here that `x` is the `(Unit → f α)` function, and it is calling that function by passing the\nUnit value `()`, which is the Unit value (Unit.unit).  All this just to ensure delayed evaluation.\n\n## How do Applicatives help with Monads?\n\nApplicatives are helpful for the same reasons as functors. They're a relatively simple abstract\nstructure that has practical applications in your code. Now that you understand how chaining\noperations can fit into a structure definition, you're in a good position to start learning about\n[Monads](monads.lean.md)!\n-/\n",
    "link": null,
    "docstring": null,
    "_type": "token"}],
  "_type": "text"}]
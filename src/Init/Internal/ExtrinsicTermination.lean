/-
Copyright (c) 2025 Lean FRO, LLC. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Paul Reichert
-/
module

prelude
import Init.Classical
import Init.Ext
public import Init.NotationExtra

set_option doc.verso true

/-!
# Fixpoints with extrinsic proofs of termination

This module provides a fixpoint combinator that does not require an immediate *intrinsic*
termination proof, but lends itself to formal verification given a deferred *extrinsic* termination
proof.

This fixpoint combinator can be seen as a compromise between using a `partial` function, which is
fully opaque, and using well-founded recursion, which requires an intrinsic termination proof.

The soundness (in a wide sense, including compatibility of kernel and compiler semantics) relies on
the same assumption as the one WF preprocessing is built upon: When two fixpoint-defining
functionals are propositionally equal, then the observable runtime behavior of their fixpoints is
identical.
-/

variable {α : Sort _} {β : α → Sort _} {γ : (a : α) → β a → Sort _}
  {C : α → Sort _} {C₂ : (a : α) → β a → Sort _} {C₃ : (a : α) → (b : β a) → γ a b → Sort _}

set_option doc.verso true

namespace Std.Internal

/--
The function implemented as the loop {lean}`opaqueFix F a = F a (opaqueFix F)`.
{lean}`opaqueFix F` is the fixpoint of the functional {name}`F`, as long as the loop is
well-founded.

The loop might run forever depending on {name}`F`. It is opaque, i.e., it is impossible to prove
nontrivial properties about it.
-/
@[specialize]
public partial def opaqueFix [∀ a, Nonempty (C a)] (F : ∀ a, (∀ a', C a') → C a) (a : α) : C a :=
  F a (opaqueFix F)

/--
{lean}`TerminatesTotally F` is the proposition that {name}`F` can be rewritten into a well-founded
recursive fixpoint functional.
-/
@[expose]
public def TerminatesTotally (F : ∀ a, (∀ a', C a') → C a) : Prop :=
  ∃ (r : α → α → Prop) (F' : (x : α) → ((y : α) → r y x → C y) → C x),
    WellFounded r ∧ ∀ x G, F x G = F' x (fun x _ => G x)

/-
SAFE assuming that the code generated by iteration over `F` is compatible
with the kernel semantics of iteration over `F' : ∀ a, (∀ a', r a' a → C a') → C a`
for all `F'` as in `TerminatesTotally`.
-/
@[implemented_by opaqueFix]
public def extrinsicFix [∀ a, Nonempty (C a)] (F : ∀ a, (∀ a', C a') → C a) (a : α) : C a :=
  open scoped Classical in
  if h : TerminatesTotally F then
    let F' := h.choose_spec.choose
    let h := h.choose_spec.choose_spec
    h.1.fix F' a
  else
    -- Return `opaqueFix F a` so that `implemented_by opaqueFix` is sound.
    -- In effect, `extrinsicFix` is opaque if `TerminatesTotally F` is false.
    opaqueFix F a

public def extrinsicFix_eq_wellFoundedFix [∀ a, Nonempty (C a)] {F : ∀ a, (∀ a', C a') → C a}
    (r : α → α → Prop) (F' : ∀ a, (∀ a', r a' a → C a') → C a)
    (wf : WellFounded r) (heq : ∀ a G, F a G = F' a (fun a' _ => G a')) {a : α} :
    extrinsicFix F a = wf.fix F' a := by
  have : TerminatesTotally F := ⟨r, F', wf, heq⟩
  simp only [extrinsicFix, dif_pos this]
  induction a using wf.induction
  rename_i x hx
  rw [WellFounded.fix_eq, WellFounded.fix_eq]
  have := this.choose_spec.choose_spec.2
  simp +contextual only [← hx, ← this, ← heq]

public noncomputable def wfFix_induction {r : α → α → Prop} {wf : WellFounded r}
    {F : ∀ a, (∀ a', r a' a → C a') → C a}
    {motive : ∀ a, C a → Sort _}
    (h : ∀ a, (∀ a', r a' a → motive a' (wf.fix F a')) → motive a (wf.fix F a))
    (a : α) :
    motive a (wf.fix F a) := by
  exact WellFounded.recursion (C := fun a' => motive a' (wf.fix F a')) wf a h

public def extrinsicFix_eq [∀ a, Nonempty (C a)] {F : ∀ a, (∀ a', C a') → C a}
    (h : TerminatesTotally F) {a : α} :
    extrinsicFix F a = F a (extrinsicFix F) := by
  simp only [extrinsicFix, dif_pos h]
  rw [WellFounded.fix_eq, show (extrinsicFix F) = (fun a' => extrinsicFix F a') by rfl]
  simp only [extrinsicFix, dif_pos h, h.choose_spec.choose_spec.2]

/--
A fixpoint combinator that allows for deferred proofs of termination.

{lean}`extrinsicFix F` is function implemented as the loop
{lean}`extrinsicFix F a = F a (extrinsicFix F)`.

If the loop can be shown to be well-founded, {name}`extrinsicFix_eq` proves that it satisfies the
fixpoint equation. Otherwise, {lean}`extrinsicFix F` is opaque, i.e., it is impossible to prove
nontrivial properties about it.
-/
add_decl_doc extrinsicFix

/--
The function implemented as the loop {lean}`opaqueFix₂ F a b = F a b (opaqueFix₂ F)`.
{lean}`opaqueFix₂ F` is the fixpoint of the functional {name}`F`, as long as the loop is
well-founded.

The loop might run forever depending on {name}`F`. It is opaque, i.e., it is impossible to prove
nontrivial properties about it.
-/
@[specialize]
public partial def opaqueFix₂ [∀ a b, Nonempty (C₂ a b)]
    (F : (a : α) → (b : β a) → ((a' : α) → (b' : β a') → C₂ a' b') → C₂ a b) (a : α) (b : β a) :
    C₂ a b :=
  F a b (opaqueFix₂ F)

/--
{lean}`TerminatesTotally₂ F` is the proposition that {name}`F` can be rewritten into a well-founded
recursive fixpoint functional.
-/
public def TerminatesTotally₂
    (F : (a : α) → (b : β a) → ((a' : α) → (b' : β a') → C₂ a' b') → C₂ a b) : Prop :=
  ∃ (r : PSigma β → PSigma β → Prop)
    (F' : (a : α) → (b : β a) → ((a' : α) → (b' : β a') → r ⟨a', b'⟩ ⟨a, b⟩ → C₂ a' b') → C₂ a b),
    WellFounded r ∧ ∀ a b G, F a b G = F' a b (fun a' b' _ => G a' b')

/-
SAFE assuming that the code generated by iteration over `F` is compatible
with the kernel semantics of iteration over
`F' : (a : α) → (b : β a) → ((a' : α) → (b' : β a') → C₂ a' b') → C₂ a b`
for all `F'` as in `TerminatesTotally₂`.
-/
@[implemented_by opaqueFix₂]
public def extrinsicFix₂ [∀ a b, Nonempty (C₂ a b)]
    (F : (a : α) → (b : β a) → ((a' : α) → (b' : β a') → C₂ a' b') → C₂ a b) (a : α) (b : β a) :
    C₂ a b :=
  let F' (x : PSigma β) (G : (y : PSigma β) → C₂ y.1 y.2) : C₂ x.1 x.2 :=
    F x.1 x.2 (fun a b => G ⟨a, b⟩)
  extrinsicFix (C := fun x : PSigma β => C₂ x.1 x.2) F' ⟨a, b⟩

public def extrinsicFix₂_eq [∀ a b, Nonempty (C₂ a b)]
    {F : (a : α) → (b : β a) → ((a' : α) → (b' : β a') → C₂ a' b') → C₂ a b}
    (h : TerminatesTotally₂ F) {a : α} {b : β a} :
    extrinsicFix₂ F a b = F a b (extrinsicFix₂ F) := by
  rw [extrinsicFix₂, extrinsicFix_eq]
  · rfl
  · let r := h.choose
    let F' := h.choose_spec.choose
    let h := h.choose_spec.choose_spec
    refine ⟨r, ?_, ?_, ?_⟩
    · exact fun x G => F' x.1 x.2 (fun a' b' rab => G ⟨a', b'⟩ rab)
    · exact h.1
    · intro x G
      apply h.2

/--
A fixpoint combinator that allows for deferred proofs of termination.

{lean}`extrinsicFix₂ F` is function implemented as the loop
{lean}`extrinsicFix₂ F a b = F a b (extrinsicFix₂ F)`.

If the loop can be shown to be well-founded, {name}`extrinsicFix₂_eq` proves that it satisfies the
fixpoint equation. Otherwise, {lean}`extrinsicFix₂ F` is opaque, i.e., it is impossible to prove
nontrivial properties about it.
-/
add_decl_doc extrinsicFix₂

/--
The function implemented as the loop {lean}`opaqueFix₃ F a b c = F a b c (opaqueFix₃ F)`.
{lean}`opaqueFix₃ F` is the fixpoint of the functional {name}`F`, as long as the loop is
well-founded.

The loop might run forever depending on {name}`F`. It is opaque, i.e., it is impossible to prove
nontrivial properties about it.
-/
@[specialize]
public partial def opaqueFix₃ [∀ a b c, Nonempty (C₃ a b c)]
    (F : ∀ (a b c), (∀ (a' b' c'), C₃ a' b' c') → C₃ a b c) (a : α) (b : β a) (c : γ a b) :
    C₃ a b c :=
  F a b c (opaqueFix₃ F)

/--
{lean}`TerminatesTotally₃ F` is the proposition that {name}`F` can be rewritten into a well-founded
recursive fixpoint functional.
-/
@[expose]
public def TerminatesTotally₃
    (F : ∀ (a b c), (∀ (a' b' c'), C₃ a' b' c') → C₃ a b c) : Prop :=
  ∃ (r : (a : α) ×' (b : β a) ×' γ a b → (a : α) ×' (b : β a) ×' γ a b → Prop)
    (F' : ∀ (a b c), (∀ (a' b' c'), r ⟨a', b', c'⟩ ⟨a, b, c⟩ → C₃ a' b' c') → C₃ a b c),
    WellFounded r ∧ ∀ a b c G, F a b c G = F' a b c (fun a' b' c' _ => G a' b' c')

/-
SAFE assuming that the code generated by iteration over `F` is compatible
with the kernel semantics of iteration over
`F' : (a : α) → (b : β a) → ((a' : α) → (b' : β a') → C₂ a' b') → C₂ a b`
for all `F'` as in `TerminatesTotally₂`.
-/
@[implemented_by opaqueFix₃]
public def extrinsicFix₃ [∀ a b c, Nonempty (C₃ a b c)]
    (F : ∀ (a b c), (∀ (a' b' c'), C₃ a' b' c') → C₃ a b c) (a : α) (b : β a) (c : γ a b) :
    C₃ a b c :=
  let F' (x : (a : α) ×' (b : β a) ×' γ a b) (G : (y : (a : α) ×' (b : β a) ×' γ a b) → C₃ y.1 y.2.1 y.2.2) : C₃ x.1 x.2.1 x.2.2 :=
    F x.1 x.2.1 x.2.2 (fun a b c => G ⟨a, b, c⟩)
  extrinsicFix (C := fun x : (a : α) ×' (b : β a) ×' γ a b => C₃ x.1 x.2.1 x.2.2) F' ⟨a, b, c⟩

public noncomputable def wellFoundedFix₃
    (r : (a : α) ×' (b : β a) ×' γ a b → (a : α) ×' (b : β a) ×' γ a b → Prop)
    (F : ∀ a b c, (∀ a' b' c', r ⟨a', b', c'⟩ ⟨a, b, c⟩ → C₃ a' b' c') → C₃ a b c)
    (wf : WellFounded r) (a b c) :
    C₃ a b c :=
  wf.fix (fun x G => F x.1 x.2.1 x.2.2 (fun a b c h => G ⟨a, b, c⟩ h)) ⟨a, b, c⟩

public def extrinsicFix₃_eq_wellFoundedFix [∀ a b c, Nonempty (C₃ a b c)]
    {F : ∀ a b c, (∀ a' b' c', C₃ a' b' c') → C₃ a b c}
    (r : (a : α) ×' (b : β a) ×' γ a b → (a : α) ×' (b : β a) ×' γ a b → Prop)
    (F' : ∀ a b c, (∀ a' b' c', r ⟨a', b', c'⟩ ⟨a, b, c⟩ → C₃ a' b' c') → C₃ a b c)
    (wf : WellFounded r) (heq : ∀ a b c G, F a b c G = F' a b c (fun a b c _ => G a b c)) {a b c} :
    extrinsicFix₃ F a b c = wf.fix (fun x G => F' x.1 x.2.1 x.2.2 (fun a b c h => G ⟨a, b, c⟩ h)) ⟨a, b, c⟩ := by
  rw [extrinsicFix₃, extrinsicFix_eq_wellFoundedFix r]
  simp +contextual [heq]

public def extrinsicFix₃_eq [∀ a b c, Nonempty (C₃ a b c)]
    {F : ∀ (a b c), (∀ (a' b' c'), C₃ a' b' c') → C₃ a b c}
    (h : TerminatesTotally₃ F) {a : α} {b : β a} {c : γ a b} :
    extrinsicFix₃ F a b c = F a b c (extrinsicFix₃ F) := by
  rw [extrinsicFix₃, extrinsicFix_eq]
  · rfl
  · let r := h.choose
    let F' := h.choose_spec.choose
    let h := h.choose_spec.choose_spec
    refine ⟨r, ?_, ?_, ?_⟩
    · exact fun x G => F' x.1 x.2.1 x.2.2 (fun a' b' c' rab => G ⟨a', b', c'⟩ rab)
    · exact h.1
    · intro x G
      apply h.2

/--
A fixpoint combinator that allows for deferred proofs of termination.

{lean}`extrinsicFix₃ F` is function implemented as the loop
{lean}`extrinsicFix₃ F a b c = F a b c (extrinsicFix₃ F)`.

If the loop can be shown to be well-founded, {name}`extrinsicFix₃_eq` proves that it satisfies the
fixpoint equation. Otherwise, {lean}`extrinsicFix₃ F` is opaque, i.e., it is impossible to prove
nontrivial properties about it.
-/
add_decl_doc extrinsicFix₃

end Std.Internal

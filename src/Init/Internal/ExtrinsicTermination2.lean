/-
Copyright (c) 2025 Lean FRO, LLC. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Paul Reichert
-/
module

prelude
import Init.Classical
import Init.Ext
public import Init.NotationExtra

set_option doc.verso true

variable {α : Sort _} {β : α → Sort _} {γ : (a : α) → β a → Sort _}
  {C : α → Sort _} {C₂ : (a : α) → β a → Sort _} {C₃ : (a : α) → (b : β a) → γ a b → Sort _}

set_option doc.verso true

namespace Std.Internal

/--
The function implemented as the loop {lean}`opaqueFixE R F a = F a (fun a _ => opaqueFixE R F a)`.
{lean}`opaqueFixE R F` is the fixpoint of the functional {name}`F`, as long as the loop is
well-founded.

The loop might run forever depending on {name}`F`. It is opaque, i.e., it is impossible to prove
nontrivial properties about it.
-/
@[specialize]
public partial def opaqueFixE [∀ a, Nonempty (C a)] (R : α → α → Prop)
    (F : ∀ a, (∀ a', R a' a → C a') → C a) (a : α) : C a :=
  F a (fun a _ => opaqueFixE R F a)

/-
SAFE assuming that the code generated by iteration over `F` is equivalent to the well-founded
fixpoint of `F` if `R` is well-founded.
-/
@[implemented_by opaqueFixE]
public def extrinsicFixE [∀ a, Nonempty (C a)] (R : α → α → Prop)
    (F : ∀ a, (∀ a', R a' a → C a') → C a) (a : α) : C a :=
  open scoped Classical in
  if h : WellFounded R then
    h.fix F a
  else
    -- Return `opaqueFixE F a` so that `implemented_by opaqueFixE` is sound.
    -- In effect, `extrinsicFixE` is opaque if `TerminatesTotally F` is false.
    opaqueFixE R F a

public theorem extrinsicFixE_eq_wellFoundedFix [∀ a, Nonempty (C a)] {R : α → α → Prop}
    {F : ∀ a, (∀ a', R a' a → C a') → C a}
    (wf : WellFounded R) {a : α} :
    extrinsicFixE R F a = wf.fix F a := by
  simp only [extrinsicFixE, dif_pos wf]

public theorem extrinsicFixE_eq [∀ a, Nonempty (C a)] {R : α → α → Prop}
    {F : ∀ a, (∀ a', R a' a → C a') → C a} (h : WellFounded R) {a : α} :
    extrinsicFixE R F a = F a (fun a _ => extrinsicFixE R F a) := by
  simp only [extrinsicFixE, dif_pos h]
  rw [WellFounded.fix_eq]

/--
A fixpoint combinator that allows for deferred proofs of termination.

{lean}`extrinsicFixE R F` is function implemented as the loop
{lean}`extrinsicFixE R F a = F a (fun a _ => extrinsicFixE R F a)`.

If the loop can be shown to be well-founded, {name}`extrinsicFixE_eq` proves that it satisfies the
fixpoint equation. Otherwise, {lean}`extrinsicFixE R F` is opaque, i.e., it is impossible to prove
nontrivial properties about it.
-/
add_decl_doc extrinsicFixE

/--
The function implemented as the loop
{lean}`opaqueFixE₂ R F a b = F a b (fun a' b' _ => opaqueFixE₂ R F a' b')`.
{lean}`opaqueFixE₂ R F` is the fixpoint of the functional {name}`F`, as long as the loop is
well-founded.

The loop might run forever depending on {name}`F`. It is opaque, i.e., it is impossible to prove
nontrivial properties about it.
-/
@[specialize]
public partial def opaqueFixE₂ [∀ a b, Nonempty (C₂ a b)]
    (R : (a : α) ×' β a → (a : α) ×' β a → Prop)
    (F : (a : α) → (b : β a) → ((a' : α) → (b' : β a') → R ⟨a', b'⟩ ⟨a, b⟩ → C₂ a' b') → C₂ a b)
    (a : α) (b : β a) :
    C₂ a b :=
  F a b (fun a' b' _ => opaqueFixE₂ R F a' b')

/-
SAFE assuming that the code generated by iteration over `F` is equivalent to the well-founded
fixpoint of `F` if `R` is well-founded.
-/
@[implemented_by opaqueFixE₂]
public def extrinsicFixE₂ [∀ a b, Nonempty (C₂ a b)]
    (R : (a : α) ×' β a → (a : α) ×' β a → Prop)
    (F : (a : α) → (b : β a) → ((a' : α) → (b' : β a') → R ⟨a', b'⟩ ⟨a, b⟩ → C₂ a' b') → C₂ a b)
    (a : α) (b : β a) :
    C₂ a b :=
  let F' (x : PSigma β) (G : (y : PSigma β) → R y x → C₂ y.1 y.2) : C₂ x.1 x.2 :=
    F x.1 x.2 (fun a b => G ⟨a, b⟩)
  extrinsicFixE (C := fun x : PSigma β => C₂ x.1 x.2) R F' ⟨a, b⟩

public theorem extrinsicFixE₂_eq [∀ a b, Nonempty (C₂ a b)]
    {R : (a : α) ×' β a → (a : α) ×' β a → Prop}
    {F : (a : α) → (b : β a) → ((a' : α) → (b' : β a') → R ⟨a', b'⟩ ⟨a, b⟩ → C₂ a' b') → C₂ a b}
    (wf : WellFounded R) {a : α} {b : β a} :
    extrinsicFixE₂ R F a b = F a b (fun a' b' _ => extrinsicFixE₂ R F a' b') := by
  rw [extrinsicFixE₂, extrinsicFixE_eq wf]
  rfl

/--
A fixpoint combinator that allows for deferred proofs of termination.

{lean}`extrinsicFixE₂ R F` is function implemented as the loop
{lean}`extrinsicFixE₂ R F a b = F a b (fun a' b' _ => extrinsicFixE₂ R F a' b')`.

If the loop can be shown to be well-founded, {name}`extrinsicFixE₂_eq` proves that it satisfies the
fixpoint equation. Otherwise, {lean}`extrinsicFixE₂ R F` is opaque, i.e., it is impossible to prove
nontrivial properties about it.
-/
add_decl_doc extrinsicFixE₂

/--
The function implemented as the loop
{lean}`opaqueFixE₃ R F a b c = F a b c (fun a' b' c' _ => opaqueFixE₃ R F a' b' c')`.
{lean}`opaqueFixE₃ R F` is the fixpoint of the functional {name}`F`, as long as the loop is
well-founded.

The loop might run forever depending on {name}`F`. It is opaque, i.e., it is impossible to prove
nontrivial properties about it.
-/
@[specialize]
public partial def opaqueFixE₃ [∀ a b c, Nonempty (C₃ a b c)]
    (R : (a : α) ×' (b : β a) ×' γ a b → (a : α) ×' (b : β a) ×' γ a b → Prop)
    (F : ∀ (a b c), (∀ (a' b' c'), R ⟨a', b', c'⟩ ⟨a, b, c⟩ → C₃ a' b' c') → C₃ a b c)
    (a : α) (b : β a) (c : γ a b) :
    C₃ a b c :=
  F a b c (fun a b c _ => opaqueFixE₃ R F a b c)

/-
SAFE assuming that the code generated by iteration over `F` is equivalent to the well-founded
fixpoint of `F` if `R` is well-founded.
-/
@[implemented_by opaqueFixE₃]
public def extrinsicFixE₃ [∀ a b c, Nonempty (C₃ a b c)]
    (R : (a : α) ×' (b : β a) ×' γ a b → (a : α) ×' (b : β a) ×' γ a b → Prop)
    (F : ∀ (a b c), (∀ (a' b' c'), R ⟨a', b', c'⟩ ⟨a, b, c⟩ → C₃ a' b' c') → C₃ a b c)
    (a : α) (b : β a) (c : γ a b) :
    C₃ a b c :=
  let F' (x : (a : α) ×' (b : β a) ×' γ a b) (G : (y : (a : α) ×' (b : β a) ×' γ a b) → R y x → C₃ y.1 y.2.1 y.2.2) :
      C₃ x.1 x.2.1 x.2.2 :=
    F x.1 x.2.1 x.2.2 (fun a b c => G ⟨a, b, c⟩)
  extrinsicFixE (C := fun x : (a : α) ×' (b : β a) ×' γ a b => C₃ x.1 x.2.1 x.2.2) R F' ⟨a, b, c⟩

public def extrinsicFixE₃_eq_wellFoundedFix [∀ a b c, Nonempty (C₃ a b c)]
    {R : (a : α) ×' (b : β a) ×' γ a b → (a : α) ×' (b : β a) ×' γ a b → Prop}
    {F : ∀ a b c, (∀ a' b' c', R ⟨a', b', c'⟩ ⟨a, b, c⟩ → C₃ a' b' c') → C₃ a b c}
    (wf : WellFounded R) {a b c} :
    extrinsicFixE₃ R F a b c = wf.fix (fun x G => F x.1 x.2.1 x.2.2 (fun a b c h => G ⟨a, b, c⟩ h)) ⟨a, b, c⟩ := by
  rw [extrinsicFixE₃, extrinsicFixE_eq_wellFoundedFix wf]

public theorem extrinsicFixE₃_eq [∀ a b c, Nonempty (C₃ a b c)]
    {R : (a : α) ×' (b : β a) ×' γ a b → (a : α) ×' (b : β a) ×' γ a b → Prop}
    {F : ∀ (a b c), (∀ (a' b' c'), R ⟨a', b', c'⟩ ⟨a, b, c⟩ → C₃ a' b' c') → C₃ a b c}
    (wf : WellFounded R) {a : α} {b : β a} {c : γ a b} :
    extrinsicFixE₃ R F a b c = F a b c (fun a b c _ => extrinsicFixE₃ R F a b c) := by
  rw [extrinsicFixE₃, extrinsicFixE_eq wf]
  rfl

/--
A fixpoint combinator that allows for deferred proofs of termination.

{lean}`extrinsicFixE₃ R F` is function implemented as the loop
{lean}`extrinsicFixE₃ R F a b c = F a b c (fun a b c _ => extrinsicFixE₃ R F a b c)`.

If the loop can be shown to be well-founded, {name}`extrinsicFixE₃_eq` proves that it satisfies the
fixpoint equation. Otherwise, {lean}`extrinsicFixE₃ R F` is opaque, i.e., it is impossible to prove
nontrivial properties about it.
-/
add_decl_doc extrinsicFixE₃

end Std.Internal

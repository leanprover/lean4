/-
Copyright (c) 2025 Lean FRO, LLC. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Wojciech Różowski
-/

module

prelude

public import Lean.Elab.PreDefinition.PartialFixpoint
public import Lean.Elab.Tactic.Rewrite
public import Lean.Meta.Tactic.Simp
namespace Lean.Elab.Command
open Lean Meta Elab

builtin_initialize
  registerTraceClass `Elab.coinductive

/-
  This file contains the main bits of the implementation of `coinductive` keyword.
  The main entry point is the `elabCoinductiveCommand` that generates `InductiveElabDescr`
  for the mutual inductive machinery, but with `isCoinductive` flag set to true.

  At the beginning, elaboration of mutual blocks where some definitions are defined via
  `coinductive` keyword is the same as of `inductive`. However, in the `mkInductiveDecl`
  just before replacing the free variables with constants and adding it to the kernel,
  we call `mkFlatInductive` that rewrites the inductives to the "flat" form, that is we add
  parameters for each of the definitions in the clique and replace recursive calls in constructors
  with these parameters. For example, the following definition

  ```
  variable (α : Type)
  coinductive infSeq (r : α → α → Prop) : α → Prop where
  | step : r a b → infSeq r b → infSeq r a
  ```

  yields the following "flat" inductive:
  ```
  inductive infSeq_functor (r : α → α → Prop) (infSeq_functor.call : α → Prop) : α → Prop where
  | step : r a b → infSeq_functor.call b → infSeq r a
  ```

  Upon such rewrite, the code for adding flat inductives does not diverge much from the usual
  way its done for inductive declarations, but we omit applying attributes/modifiers and
  we do not set the syntax references to track those declarations (as this is auxillary piece of
  data hidden from the user).

  Then, upon adding such flat inductives for each definition in the mutual block to the environment,
  we use `Meta.MkIffOfInductiveProp` machinery to rewrite those to predicates made of disjunctions
  and existentials that we will refer to as "existential" form. This form makes it easy to generate
  user-readable coinduction proof principles and allows to use existing `monotonicity` tactic.

  For example, the above flat inductive corresponds to:
  ```
    def infSeq_functor.existential : (α : Type) → (α → α → Prop) → (α → Prop) → α → Prop :=
      fun α r infSeq_functor.call a => ∃ b, r a b ∧ infSeq_functor.call b
  ```

  Both forms are connected through the following lemma (that is generated by
  `Meta.MkIffOfInductive`) machinery:
  ```
    infSeq_functor.existential_equiv (α : Type) (r : α → α → Prop)
      (infSeq_functor.call : α → Prop) (a✝ : α) :
      infSeq_functor α r infSeq_functor.call a✝ ↔ ∃ b, r a✝ b ∧ infSeq_functor.call b
  ```

  Those definitions are used to populate `PreDefinition`s that are then passed to `PartialFixpoint`
  machinery.

  At that stage all predicates (if definitions are monotone) are added to the environment.
  Note that at this point `PartialFixpoint` machinery applies the attributes and modifiers. We
  use the syntax references from the original `InductiveView`s and set them to those declarations.

  Finally, we use the fixpoint unrolling rule and equivalence between flat inductive and
  existential forms and declare all the constructors from the definition. For example, we obtain:
  ```
    infSeq.step (α : Type) (r : α → α → Prop) {a b : α} : r a b → infSeq α r b → infSeq α r a
  ```

  At the very end, we make use of the syntax references from the original `InductiveView`s
  and set them to newly generated constructors.
-/

/-- This structure contains the data carried in `InductiveElabStep1` that are solely used in
mutual coinductive predicate elaboration. -/
public structure CoinductiveElabData where
  /-- Declaration name of the predicate-/
  declName : Name
  /-- Ref from the original `InductiveView`-/
  ref : Syntax
  /-- Modifiers from the original `InductiveView`-/
  modifiers : Modifiers
  /-- Constructor refs from the original `InductiveView`-/
  ctorSyntax : Array Syntax
  /-- The flag that is `true` if the predicate was defined via `coinductive` keyword and `false`
  otherwise. When we elaborate a mutual definition, we allow mixing `coinductive` and `inductive`
  keywords, and hence we need to record this information.
  -/
  isGreatest : Bool
  deriving Inhabited

public def addFunctorPostfix : Name → Name
  | Name.anonymous => Name.anonymous
  | Name.str p s => Name.str p (s ++ "_functor")
  | Name.num p n => Name.num (addFunctorPostfix p) n

public def removeFunctorPostfix : Name → Name
  | Name.anonymous => Name.anonymous
  | Name.str p s => Name.str p (s.stripSuffix "_functor")
  | Name.num p n => Name.num (removeFunctorPostfix p) n

public def removeFunctorPostfixInCtor : Name → Name
  | Name.anonymous => Name.anonymous
  | Name.str p s => Name.str (removeFunctorPostfix p) s
  | Name.num p n => Name.num (removeFunctorPostfixInCtor p) n

/--
  Defines a constructor for a coinductive predicate that precisely correspond to the constructors
  given in the original `InductiveView`. First, we take all the parameters and arguments
  of the constructor, look at flat inductive (see `mkFlatInductive`) associated with our definition,
  and then we populate the parameters corresponding to recursive calls with the just defined
  coinductive predicates. Once we have this, we rewrite the obtained flat inductive to equivalent
  existential form (see `Meta.MkIffOfInductivePRop`), and then we use the unrolling rule registered
  by `PartialFixpoint` machinery to bring the goal to the form corresponding to the conclusion of
  the constructor.

-/
private def generateCoinductiveConstructor (infos : Array InductiveVal) (ctorSyntax : Syntax)
    (numParams : Nat) (name : Name) (ctor : ConstructorVal) : TermElabM Unit := do
  trace[Elab.coinductive] "Generating constructor: {removeFunctorPostfixInCtor ctor.name}"
  let numPreds := infos.size
  let predNames := infos.map fun val => removeFunctorPostfix val.name
  let levelParams := infos[0]!.levelParams.map mkLevelParam
  /-
    We start by looking at the type of the constructor of the flat inductive and then by introducing
    all its parameters to the scope.
  -/
  forallBoundedTelescope ctor.type (numParams + numPreds) fun args body => do
    /-
      The first `numParams` many items of `args` are parameters from the original definition,
      while the remaining ones are free variables that correspond to recursive calls.
    -/
    let params := args.take numParams
    let predFVars := args.extract numParams
    /-
      We will fill recursive calls in the body with the just defined (co)inductive predicates.
    -/
    let mut predicates : Array Expr := predNames.map (mkConst · levelParams)
    predicates := predicates.map (mkAppN · params)
    let body := body.replaceFVars predFVars predicates
    /-
      Now, we look at the rest of the constructor.
      We start by collecting its non-parameter premises, as well as inspecting its conclusion.
    -/
    let res ← forallTelescope body fun bodyArgs bodyExpr => do
      /-
        First, we look at conclusion and pick out all arguments that are non-parameters.
      -/
      let bodyAppArgs := bodyExpr.getAppArgs.extract (numParams + infos.size)
      /-
        The goal (i.e. right hands side of a constructor) that we are trying to make is just
        the coinductive predicate with parameters and non-parameter arguments applied.
      -/
      let goalType := mkConst (removeFunctorPostfix name) levelParams
      let mut goalType := mkAppN goalType params
      goalType := mkAppN goalType bodyAppArgs
      trace[Elab.coinductive] "The conclusion of the constructor {ctor.name} is {goalType}"

      -- We start by making the metavariable for it, that we will fill
      let goal ← mkFreshExprMVar <| .some goalType
      let hole := Expr.mvarId! goal

      /-
        First, we will reply on the unrolling rule that is registered by `PartialFixpoint` machinery
      -/
      let some fixEq
        ← PartialFixpoint.getUnfoldFor? (removeFunctorPostfix name) | throwError "No unfold lemma"
      let mut fixEq := mkConst fixEq levelParams
      fixEq := mkAppN fixEq params
      /-
        The right hands side of the unrolling rule is existential form of the flat inductive
        defining the predicate with all its arguments applied
      -/
      let mut unfolded := mkConst (name ++ `existential) levelParams
      unfolded ← unfoldDefinition unfolded
      unfolded := mkAppN unfolded bodyExpr.getAppArgs
      unfolded ← whnf unfolded
      /-
        Before we apply the unrolling lemma, we need to bring it to the appropriate form,
        in which all arguments are applied
      -/
      for arg in bodyAppArgs do
        fixEq ← mkAppM ``congrFun #[fixEq, arg]
      /-
        We rewrite by the unrolling rule, the goal is now in the existential form
      -/
      let hole ← Lean.MVarId.replaceTargetEq hole unfolded fixEq
      /-
        To bring it to the flat inductive type form, we need to apply
        the lemma that connects both. We instantiate it, and get an appropriate implication.
      -/
      let equivLemmaName := name ++ `existential_equiv
      let mut equivLemma := mkConst equivLemmaName levelParams
      equivLemma := mkAppN equivLemma bodyExpr.getAppArgs
      equivLemma ← mkAppM ``Iff.mp #[equivLemma]
      let [hole] ← hole.apply equivLemma | throwError "Could not apply {equivLemmaName}"
      /-
        Now, all it suffices is to call an approprate constructor of the flat inductive.
      -/
      let constructor := mkConst ctor.name levelParams
      let constructor := mkAppN constructor params
      let constructor := mkAppN constructor predicates
      let constructor := mkAppN constructor bodyArgs
      hole.assign constructor
      let conclusion ← instantiateMVars goal
      let conclusion ← mkLambdaFVars bodyArgs conclusion
      mkLambdaFVars params conclusion
    let type ← inferType res
    trace[Elab.coinductive] "The elaborated constructor is of the type: {type}"
    /-
      We finish by registering the appropriate declaration
    -/
    addDecl <| .defnDecl (←mkDefinitionValInferringUnsafe
      (removeFunctorPostfixInCtor ctor.name) ctor.levelParams type res .opaque)
    Term.addTermInfo' ctorSyntax res (isBinder := true)

/--
  Given the number of parameters and the `InductiveVal` containing flat inductives
  (see `mkFlatInductive`) and `CoinductiveElabData` associated with the mutual coinductive
  predicates, generates their constructors that correspond to the
  constructors given in the original syntax.
-/
private def generateCoinductiveConstructors (numParams : Nat) (infos : Array InductiveVal)
    (coinductiveElabData : Array CoinductiveElabData) : TermElabM Unit := do
  for indType in infos, e in coinductiveElabData do
    for ctor in indType.ctors, ctorSyntax in e.ctorSyntax do
      generateCoinductiveConstructor infos ctorSyntax numParams indType.name
        <| ←getConstInfoCtor ctor

private def generateEqLemmas (infos : Array InductiveVal) : MetaM Unit := do
  trace[Elab.coinductive] "called generateEqLemmas"
  let levels := infos[0]!.levelParams.map mkLevelParam
  for info in infos do
    let res ← forallTelescopeReducing info.type fun args _ => do
      let params := args.take <| info.numParams - infos.size
      let args := args.extract info.numParams

      let lhs := mkConst (removeFunctorPostfix info.name) levels
      let lhs := mkAppN lhs params
      let lhs := mkAppN lhs args

      let calls := infos.map fun info => mkAppN (mkConst (removeFunctorPostfix info.name) levels) params
      let rhs := mkConst info.name levels
      let rhs := mkAppN rhs params
      let rhs := mkAppN rhs calls
      let rhs := mkAppN rhs args

      let goalType ← mkEq lhs rhs
      let goal ← mkFreshExprMVar goalType

      let goalMVarId := goal.mvarId!

      let .some #[fixEq] ←  getEqnsFor? (removeFunctorPostfix info.name) | throwError "did not generate unfolding theorem"
      let existentialEquiv := mkConst (info.name ++ `existential_equiv) levels

      let mut fixEq := mkConst fixEq levels
      fixEq := mkAppN fixEq params
      for arg in args do
        fixEq ← mkCongrFun fixEq arg

      let rwRes ← goalMVarId.rewrite (←goalMVarId.getType) existentialEquiv
      let newGoal ← goalMVarId.replaceTargetEq rwRes.eNew rwRes.eqProof
      newGoal.assign fixEq

      let goal ← instantiateMVars goal
      mkLambdaFVars (params ++ args) goal
    trace[Elab.coinductive] "res: {res}"
    addDecl <| .defnDecl (←mkDefinitionValInferringUnsafe
      ((removeFunctorPostfix info.name) ++ `functor_unfold) info.levelParams (←inferType res) res .opaque)

private def mkCasesOnCoinductive (infos : Array InductiveVal) : MetaM Unit := do
  let levels := infos[0]!.levelParams.map mkLevelParam
  let allCtors := infos.flatMap (·.ctors.toArray)
  trace[Elab.coinductive] "allCtors: {allCtors}"
  forallBoundedTelescope infos[0]!.type (infos[0]!.numParams - infos.size) fun params _ => do
  let predicates := infos.map fun info => mkConst (removeFunctorPostfix info.name) levels
  let predicates := predicates.map (mkAppN · params)
  for info in infos do
    trace[Elab.coinductive] "params are: {params}"
    let originalCasesOn ← mkConstWithLevelParams (info.name ++ `casesOn)
    let originalCasesOn := mkAppN originalCasesOn params
    let originalCasesOn := mkAppN originalCasesOn predicates

    trace[Elab.coinductive] "originalCasesOn: {originalCasesOn}"

    let goalType ← inferType originalCasesOn
    -- We replace the mentions of the flat inductive with a coinductive predicate
    let goalType := goalType.replace (fun e =>
      if e.isAppOf info.name then
        let bodyArgs := e.getAppArgs.extract info.numParams
        mkAppN (mkConst (removeFunctorPostfix info.name) levels) <| params ++ bodyArgs
      else
        none
    )
    -- We then replace all constructors of the original type
    let goalType := goalType.replace (fun e =>
      if allCtors.any e.isAppOf then
        let bodyArgs := e.getAppArgs.extract info.numParams
        mkAppN (mkConst (removeFunctorPostfixInCtor (e.getAppFn.constName)) levels) <| params ++ bodyArgs
      else none
    )

    let originalType ← inferType originalCasesOn
    -- We start from the motive type

    forallBoundedTelescope goalType (.some 1) fun args goalType => do
      let #[motive] := args | throwError "Expected one argument"
      trace[Elab.coinductive] "motive: {motive}"
      let (Expr.forallE _ type _ _) := originalType | throwError "expected to be quantifier"
      let motiveMVar ← mkFreshExprMVar type
      let (fvars, subgoal) ← motiveMVar.mvarId!.introN (info.numIndices + 1)
      subgoal.withContext do
        let eqProof := mkConst ((removeFunctorPostfix info.name) ++ `functor_unfold) levels
        trace[Elab.coinductive] "motiveMVar: {motiveMVar}"
        trace[Elab.coinductive] "fvars: {fvars.map (Expr.fvar)}"
        let res := ((←getLCtx).get! (fvars[fvars.size -1]!)).type
        let rewriteResult ← subgoal.rewrite res eqProof (symm := true)
        trace[Elab.coinductive] "res: {rewriteResult.eNew}"
        let res2 ←  subgoal.replaceLocalDecl fvars[fvars.size -1]! rewriteResult.eNew rewriteResult.eqProof
        let (_, res3) ← res2.mvarId.revert (fvars.extract 0 (fvars.size -1) ++  #[res2.fvarId])
        res3.assign motive
        let originalCasesOn := mkApp originalCasesOn motiveMVar

        forallBoundedTelescope goalType info.numIndices fun indices goalType => do
          let originalCasesOn := mkAppN originalCasesOn indices
          forallBoundedTelescope goalType (.some 1) fun args goalType => do
            let #[target] := args | throwError "Expected one argument"
            let (Expr.forallE _ type _ _) ← inferType originalCasesOn | throwError "expected to be quantifier"
            let targetMVar ← mkFreshExprMVar type
            let targetRewriteRes ← targetMVar.mvarId!.rewrite (←targetMVar.mvarId!.getType) eqProof (symm := true)
            let targetMVarSubgoal ← targetMVar.mvarId!.replaceTargetEq targetRewriteRes.eNew targetRewriteRes.eqProof

            trace[Elab.coinductive] "{targetMVarSubgoal}, target: {target}"

        -- forallBoundedTelescope goalType (info.numIndices) fun indices goalType => do
        --   let goal ← mkFreshExprMVar goalType

        --   let res := subst goal.mvarId!
        --   let originalCasesOn := mkAppN originalCasesOn indices
        --   forallBoundedTelescope goalType (.some 1) fun args goalType => do
        --     let #[predicateOccurence] := args | throwError "Expected one argument"
        --     trace[Elab.coinductive] "predicateOccurence: {predicateOccurence}"
        --     let (Expr.forallE _ type _ _) ← inferType originalCasesOn | throwError "expected to be quantifier"
        --     let predicateOccurenceMVar ← mkFreshExprMVar type
        --     let predicateOccurenceMVarId := predicateOccurenceMVar.mvarId!
            -- let rewriteResult ← predicateOccurenceMVarId.rewrite (←predicateOccurenceMVarId.getType) (mkConst ((removeFunctorPostfix info.name) ++ `functor_unfold) levels) (symm := true)
            -- let subgoal2 ← predicateOccurenceMVarId.replaceTargetDefEq rewriteResult.eNew --rewriteResult.eqProof
            -- subgoal2.assign predicateOccurence

            -- let originalCasesOn := mkApp originalCasesOn predicateOccurenceMVar
            -- trace[Elab.coinductive] "originalCasesOn: {originalCasesOn}"

          --   let (goals, _, body) ← forallMetaTelescope (←inferType originalCasesOn)
          --   for goal in goals do
          --     let mvarId := goal.mvarId!
          --     let (fvars, subgoal) ← mvarId.intros
          --     let res ← subgoal.rewrite (←subgoal.getType) (mkConst ((removeFunctorPostfix info.name) ++ `functor_unfold) levels) (symm := false)
          --     trace[Elab.coinductive] "{res.eNew}"


    -- forallTelescope goalType fun goalArgs goal => do
    --   trace[Elab.coinductive] "goalArgs: {goalArgs}"
    --   -- motive
    --   let (casesOnArgs, _ , casesOnBody) ← forallMetaTelescope (←inferType originalCasesOn)
    --   let motive := casesOnArgs[0]!
    --   let (fvars, subgoal) ← motive.mvarId!.introN info.numIndices
    --   let rewriteResult ← subgoal.rewrite (←subgoal.getType) (mkConst ((removeFunctorPostfix info.name) ++ `functor_unfold) levels) (symm := true)
    --   let subgoal2 ← subgoal.replaceTargetEq rewriteResult.eNew rewriteResult.eqProof
    --   let (_, subgoal3) ← subgoal2.revert fvars

    --   trace[Elab.coinductive] "TEST1: {Expr.mvar subgoal3}, {goalArgs[0]!}"

    --   subgoal3.assign goalArgs[0]!
    --   let originalCasesOn := mkApp originalCasesOn motive

    --   -- indices
    --   let indices := goalArgs.extract 1 (info.numIndices + 1)
    --   let indicesMVars := casesOnArgs.extract 1 (info.numIndices + 1)
    --   discard <| indicesMVars.mapIdxM fun idx mv => do
    --     mv.mvarId!.assign indices[idx]!
    --   let originalCasesOn := mkAppN originalCasesOn indicesMVars

    --   -- mention of the predicate
    --   let mention := goalArgs[info.numIndices + 1]!
    --   let mentionMVar := casesOnArgs[info.numIndices + 1]!
    --   let rewriteResult ← mentionMVar.mvarId!.rewrite (←mentionMVar.mvarId!.getType) (mkConst ((removeFunctorPostfix info.name) ++ `functor_unfold) levels) (symm := true)
    --   let mentionSubgoal ← mentionMVar.mvarId!.replaceTargetEq rewriteResult.eNew rewriteResult.eqProof
    --   mentionSubgoal.assign mention

    --   let originalCasesOn := mkApp originalCasesOn mentionMVar
    --   trace[Elab.coinductive] "res: {originalCasesOn}"
    --   -- Individual constructors
    --   let ctorHyps := goalArgs.extract <| info.numIndices + 2
    --   let ctorHypsMVar := casesOnArgs.extract <| info.numIndices + 2

    --   discard <| ctorHypsMVar.mapIdxM fun idx mv => do
    --     mv.mvarId!.assign ctorHyps[idx]!

      -- let originalCasesOn := mkAppN originalCasesOn ctorHypsMVar

      -- trace[Elab.coinductive] "res: {originalCasesOn}"

      -- let finalGoal ← mkFreshExprMVar goal

      -- finalGoal.mvarId!.assign originalCasesOn

      -- let res ← mkLambdaFVars goalArgs finalGoal
      -- let res ← mkLambdaFVars params res

      -- let res ← instantiateMVars res

      -- addDecl <| .defnDecl (←mkDefinitionValInferringUnsafe
      -- ((removeFunctorPostfix info.name) ++ `casesOn) info.levelParams (←inferType res) res .opaque)


  pure ()
/--
  Main entry point for elaborating mutual coinductive predicates. This function is called after
  generating a flat inductive and adding it to the environment.

  We look at corresponding existential form of the flat inductive (see `Meta.MkIffOfInductiveProp`),
  use it to populate `PreDefinition`s that correspond to the predicates, and then we call
  the `PartialFixpoint` machinery to register them as (co)inductive predicates.

  Finally, we generate constructors for each of the predicates, that correspond to the constructors
  that were given by the user.
-/
public def elabCoinductive (coinductiveElabData : Array CoinductiveElabData) : TermElabM Unit := do
  trace[Elab.coinductive] "Elaborating: {coinductiveElabData.map (·.declName)}"
  let infos ← coinductiveElabData.mapM (getConstInfoInduct ·.declName)
  let levelParams := infos[0]!.levelParams.map mkLevelParam
  /-
    We infer original names and types of the predicates.
    To get such names, we need to remove `_functor` postfix. At the same time,
    we need to forget about the parameters for recursive calls, to get the original types.
  -/
  let originalNumParams := infos[0]!.numParams - infos.size
  let namesAndTypes : Array (Name × Expr) ← infos.mapM fun info => do
    let type ← forallTelescope info.type fun args body => do
      mkForallFVars (args.take originalNumParams ++ args.extract info.numParams) body
    return (removeFunctorPostfix (info.name), type)
  /-
    We make dummy constants that are used in populating PreDefinitions
  -/
  let consts := namesAndTypes.map fun (name, _) => (mkConst name levelParams)
  for const in consts, e in coinductiveElabData do
    Term.addTermInfo' e.ref const (isBinder := true)
  /-
    We create values of each of PreDefinitions, by taking existential (see `Meta.SumOfProducts`)
    form of the associated flat inductives and applying paramaters, as well as recursive calls
    (with their parameters passed).
  -/
  let preDefVals ← forallBoundedTelescope infos[0]!.type originalNumParams fun params _ => do
    infos.mapM fun info => do
      let mut functor := mkConst (info.name ++ `existential) levelParams
      functor ← unfoldDefinition functor
      functor := mkAppN functor <| params ++ consts.map (mkAppN · <| params)
      mkLambdaFVars params functor
  /-
    Finally, we populate the PreDefinitions
  -/
  let preDefs : Array PreDefinition := preDefVals.mapIdx fun idx defn =>
    { ref := coinductiveElabData[idx]!.ref
      binders := coinductiveElabData[idx]!.ref
      kind := .def
      levelParams := infos[0]!.levelParams
      modifiers := coinductiveElabData[idx]!.modifiers
      declName := namesAndTypes[idx]!.1
      type := namesAndTypes[idx]!.2
      value := defn
      termination := {
        ref := coinductiveElabData[idx]!.ref
        terminationBy?? := .none
        terminationBy? := .none
        partialFixpoint? := .some {
            ref := coinductiveElabData[idx]!.ref
            term? := .none
            fixpointType := if coinductiveElabData[idx]!.isGreatest then
                              .coinductiveFixpoint else .inductiveFixpoint
        }
        decreasingBy? := .none
        extraParams := 0
      }
    }
  partialFixpoint (← getLCtx, ← getLocalInstances) preDefs
  generateEqLemmas infos
  generateCoinductiveConstructors originalNumParams infos coinductiveElabData
  mkCasesOnCoinductive infos

end Lean.Elab.Command

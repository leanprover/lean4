{
    "$schema": "https://json-schema.org/draft-04/schema#",
    "title": "lakefile.toml",
    "description": "Configuration file for Lean's build system, Lake",
    "type": "object",
    "definitions": {
        "leanOptionValue": {
            "type": [
                "string",
                "boolean",
                "integer",
                "object"
            ],
            "minimum": 0,
            "additionalProperties": {
                "$ref": "#/definitions/leanOptionValue"
            },
            "description": "A `set_option` string / boolean / natural number configuration value."
        },
        "leanConfig": {
            "properties": {
                "buildType": {
                    "type": "string",
                    "enum": [
                        "debug", "Debug",
                        "relWithDebInfo", "RelWithDebInfo",
                        "minSizeRel", "MinSizeRel",
                        "release", "Release"
                    ],
                    "default": "release",
                    "description": "The mode in which the modules should be built."
                },
                "leanOptions": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "#/definitions/leanOptionValue"
                    },
                    "default": {},
                    "description": "Additional `set_option` options to pass to both the Lean language server launched by `lake serve` and to `lean` when compiling a module's Lean source files."
                },
                "moreServerOptions": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "#/definitions/leanOptionValue"
                    },
                    "default": {},
                    "description": "Additional `set_option` options to pass only to the Lean language server (i.e., `lean --server`) launched by `lake serve`."
                },
                "moreLeanArgs": {
                    "type": "array",
                    "items": {
                        "type": "string",
                        "description": "An additional command-line argument to pass to `lean` when compiling a module's Lean source files."
                    },
                    "default": [],
                    "description": "Additional command-line arguments to pass to `lean` when compiling a module's Lean source files."
                },
                "weakLeanArgs": {
                    "type": "array",
                    "items": {
                        "type": "string",
                        "description": "An additional command-line argument to pass to `lean` when compiling a module's Lean source files."
                    },
                    "default": [],
                    "description": "Additional command-line arguments to pass to `lean` when compiling a module's Lean source files.\n\nUnlike `moreLeanArgs`, these arguments do not affect the trace of the build result, so they can be changed without triggering a rebuild.\nThey come *before* `moreLeanArgs`."
                },
                "moreLeancArgs": {
                    "type": "array",
                    "items": {
                        "type": "string",
                        "description": "An additional command-line argument to pass to `leanc` when compiling a module's C source files generated by `lean`."
                    },
                    "default": [],
                    "description": "Additional command-line arguments to pass to `leanc` when compiling a module's C source files generated by `lean`.\n\nLake already passes some flags based on the `buildType`, but you can change this by, for example, adding `-O0` and `-UNDEBUG`."
                },
                "weakLeancArgs": {
                    "type": "array",
                    "items": {
                        "type": "string",
                        "description": "An additional command-line argument to pass to `leanc` when compiling a module's C source files generated by `lean`."
                    },
                    "default": [],
                    "description": "Additional command-line arguments to pass to `leanc` when compiling a module's C source files generated by `lean`.\n\nUnlike `moreLeancArgs`, these arguments do not affect the trace of the build result, so they can be changed without triggering a rebuild.\nThey come *before* `moreLeancArgs`."
                },
                "moreLinkObjs": {
                    "type": "array",
                    "items": {
                        "type": "string",
                        "description": "Build key identifier of an additional target object to use when linking (both static and shared).\n\nFormat: `<target>[:<facet>]*`, where:\n- `<target>` is of the form `@<package>`, `@<package>/<targetName>`, +<module>` or `@<package>/+<module>`,\n- `<package>` may be empty to reference the default package,\n- `<facet>` is the name of a target facet."
                    },
                    "default": [],
                    "description": "Build key identifiers of additional target objects to use when linking (both static and shared).\n\nFormat: `<target>[:<facet>]*`, where:\n- `<target>` is of the form `@<package>`, `@<package>/<targetName>`, +<module>` or `@<package>/+<module>`,\n- `<package>` may be empty to reference the default package,\n- `<facet>` is the name of a target facet.\n\nBuild key identifiers come *after* the paths of native facets."
                },
                "moreLinkLibs": {
                    "type": "array",
                    "items": {
                        "type": "string",
                        "description": "Build key identifier of additional target libraries to pass to `leanc` when linking (e.g., for shared libraries or binary executables).\n\nFormat: `<target>[:<facet>]*`, where:\n- `<target>` is of the form `@<package>`, `@<package>/<targetName>`, +<module>` or `@<package>/+<module>`,\n- `<package>` may be empty to reference the default package,\n- `<facet>` is the name of a target facet."
                    },
                    "default": [],
                    "description": "Build key identifiers of additional target libraries to pass to `leanc` when linking (e.g., for shared libraries or binary executables).\n\nFormat: `<target>[:<facet>]*`, where:\n- `<target>` is of the form `@<package>`, `@<package>/<targetName>`, +<module>` or `@<package>/+<module>`,\n- `<package>` may be empty to reference the default package,\n- `<facet>` is the name of a target facet.\n\nThese come *after* the paths of other link objects."
                },
                "moreLinkArgs": {
                    "type": "array",
                    "items": {
                        "type": "string",
                        "description": "Additional command-line argument to pass to `leanc` when linking (e.g., for shared libraries or binary executables)."
                    },
                    "default": [],
                    "description": "Additional command-line arguments to pass to `leanc` when linking (e.g., for shared libraries or binary executables). These come *after* the paths of the linked objects."
                },
                "weakLinkArgs": {
                    "type": "array",
                    "items": {
                        "type": "string",
                        "description": "Additional command-line argument to pass to `leanc` when linking (e.g., for shared libraries or binary executables)."
                    },
                    "default": [],
                    "description": "Additional command-line arguments to pass to `leanc` when linking (e.g., for shared libraries or binary executables). These come *after* the paths of the linked objects.\n\nUnlike `moreLinkArgs`, these arguments do not affect the trace of the build result, so they can be changed without triggering a rebuild.\nThey come *before* `moreLinkArgs`."
                },
                "backend": {
                    "type": "string",
                    "enum": [
                        "default",
                        "c",
                        "llvm"
                    ],
                    "default": "default",
                    "description": "Compiler backend that modules should be built with (`C` or `LLVM`). `default` corresponds to `C`."
                },
                "platformIndependent": {
                    "type": "boolean",
                    "description": "Asserts whether Lake should assume Lean modules are platform-independent.\n\n* If `false`, Lake will add `System.Platform.target` to the module traces within the code unit (e.g., package or library). This will force Lean code to be re-elaborated on different platforms.\n\n* If `true`, Lake will exclude platform-dependent elements (e.g., precompiled modules, external libraries) from a module's trace, preventing re-elaboration on different platforms. Note that this will not effect modules outside the code unit in question. For example, a platform-independent package which depends on a platform-dependent library will still be platform-dependent.\n\n* If not set, Lake will construct traces as natural. That is, it will include platform-dependent artifacts in the trace if they module depends on them, but otherwise not force modules to be platform-dependent.\n\nThere is no check  for correctness here, so a configuration can lie and Lake will not catch it."
                },
                "dynlibs": {
                    "type": "array",
                    "items": {
                        "type": "string",
                        "description": "Build key identifier of dynamic library target to load during the elaboration of a module (via `lean --load-dynlib`).\n\nFormat: `<target>[:<facet>]*`, where:\n- `<target>` is of the form `@<package>`, `@<package>/<targetName>`, +<module>` or `@<package>/+<module>`,\n- `<package>` may be empty to reference the default package,\n- `<facet>` is the name of a target facet."
                    },
                    "default": [],
                    "description": "Build key identifiers of dynamic library targets to load during the elaboration of a module (via `lean --load-dynlib`).\n\nFormat: `<target>[:<facet>]*`, where:\n- `<target>` is of the form `@<package>`, `@<package>/<targetName>`, +<module>` or `@<package>/+<module>`,\n- `<package>` may be empty to reference the default package,\n- `<facet>` is the name of a target facet."
                },
                "plugins": {
                    "type": "array",
                    "items": {
                        "type": "string",
                        "description": "Build key identifier of Lean plugin target to load during the elaboration of a module (via `lean --plugin`).\n\nFormat: `<target>[:<facet>]*`, where:\n- `<target>` is of the form `@<package>`, `@<package>/<targetName>`, +<module>` or `@<package>/+<module>`,\n- `<package>` may be empty to reference the default package,\n- `<facet>` is the name of a target facet."
                    },
                    "default": [],
                    "description": "Build key identifiers of Lean plugin targets to load during the elaboration of a module (via `lean --plugin`).\n\nFormat: `<target>[:<facet>]*`, where:\n- `<target>` is of the form `@<package>`, `@<package>/<targetName>`, +<module>` or `@<package>/+<module>`,\n- `<package>` may be empty to reference the default package,\n- `<facet>` is the name of a target facet."
                }
            }
        },
        "leanLibConfig": {
            "allOf": [
                {
                    "$ref": "#/definitions/leanConfig"
                },
                {
                    "properties": {
                        "name": {
                            "type": "string",
                            "description": "Name of the library."
                        },
                        "srcDir": {
                            "type": "string",
                            "default": ".",
                            "description": "The subdirectory of the package's source directory containing the library's Lean source files.\n\n(This will be passed to `lean` as the `-R` option.)"
                        },
                        "roots": {
                            "type": "array",
                            "items": {
                                "type": "string",
                                "description": "A root module of the library.\nSubmodules of this root (e.g., `Lib.Foo` of `Lib`) are considered part of the library."
                            },
                            "description": "The root module(s) of the library.\nSubmodules of these roots (e.g., `Lib.Foo` of `Lib`) are considered part of the library.\nDefaults to a single root of the target's name."
                        },
                        "globs": {
                            "type": "array",
                            "items": {
                                "type": "string",
                                "description": "Glob that specifies what to build for the library.\n\nSubmodule globs build every source file within their directory.\nLocal imports of glob'ed files (i.e., fellow modules of the workspace) are also recursively built.\n\nFormat:\n- `<moduleName>` (select `moduleName`), or\n- `<moduleName>.+` (select all submodules of `moduleName`, but not `moduleName` itself), or\n- `<moduleName>.*` (select all submodule of `moduleName` and `moduleName itself`)."
                            },
                            "description": "Globs that specify what to build for the library.\nDefaults to building each of the library's `roots`.\n\nSubmodule globs build every source file within their directory.\nLocal imports of glob'ed files (i.e., fellow modules of the workspace) are also recursively built.\n\nFormat:\n- `<moduleName>` (select `moduleName`), or\n- `<moduleName>.+` (select all submodules of `moduleName`, but not `moduleName` itself), or\n- `<moduleName>.*` (select all submodule of `moduleName` and `moduleName itself`)."
                        },
                        "libName": {
                            "type": "string",
                            "description": "The name of the library artifact.\nUsed as a base for the file names of its static and dynamic binaries.\nDefaults to the mangled name of the target."
                        },
                        "libPrefixOnWindows": {
                            "type": "boolean",
                            "default": false,
                            "description": "Whether static and shared binaries of this library should be prefixed with `lib` on Windows.\n\nUnlike Unix, Windows does not require native libraries to start with `lib` and, by convention, they usually do not. However, for consistent naming across all platforms, users may wish to enable this.\n\nDefaults to `false`."
                        },
                        "allowImportAll": {
                            "type": "boolean",
                            "default": false,
                            "description": "Whether downstream packages can `import all` modules of this library.\n\nIf enabled, downstream users will be able to access the `private` internals of modules, including definition bodies not marked as `@[expose]`. This may also, in the future, prevent compiler optimization which rely on `private` definitions being inaccessible outside their own package."
                        },
                        "needs": {
                            "type": "array",
                            "items": {
                                "type": "string",
                                "description": "Build target identifier of target to build before the library's modules.\n\nFormat: `<target>[:<facet>]*`, where:\n- `<target>` is of the form `@<package>`, `@<package>/<targetName>`, +<module>` or `@<package>/+<module>`,\n- `<package>` may be empty to reference the default package,\n- `<facet>` is the name of a target facet."
                            },
                            "default": [],
                            "description": "Build target identifiers of targets to build before the library's modules.\n\nFormat: `<target>[:<facet>]*`, where:\n- `<target>` is of the form `@<package>`, `@<package>/<targetName>`, +<module>` or `@<package>/+<module>`,\n- `<package>` may be empty to reference the default package,\n- `<facet>` is the name of a target facet."
                        },
                        "precompileModules": {
                            "type": "boolean",
                            "default": false,
                            "description": "Whether to compile each of the library's modules into a native shared library that is loaded whenever the module is imported. This speeds up evaluation of metaprograms and enables the interpreter to run functions marked `@[extern]`."
                        },
                        "defaultFacets": {
                            "type": "array",
                            "items": {
                                "type": "string",
                                "description": "A library facet to build on a bare `lake build` of the library.\nFor example, `shared` will build the shared library facet."
                            },
                            "default": [
                                "leanArts"
                            ],
                            "description": "An array of library facets to build on a bare `lake build` of the library.\nFor example, `[shared]` will build the shared library facet."
                        }
                    },
                    "required": [
                        "name"
                    ],
                    "x-taplo": {
                        "initKeys": [
                            "name"
                        ]
                    }
                }
            ]
        },
        "leanExeConfig": {
            "allOf": [
                {
                    "$ref": "#/definitions/leanConfig"
                },
                {
                    "properties": {
                        "name": {
                            "type": "string",
                            "description": "The name of the executable."
                        },
                        "srcDir": {
                            "type": "string",
                            "default": ".",
                            "description": "The subdirectory of the package's source directory containing the executable's Lean source file.\n\n(This will be passed to `lean` as the `-R` option.)"
                        },
                        "root": {
                            "type": "string",
                            "description": "The root module of the binary executable.\nShould include a `main` definition that will serve as the entry point of the program.\n\nThe root is built by recursively building its local imports (i.e., fellow modules of the workspace).\n\nDefaults to the name of the target."
                        },
                        "exeName": {
                            "type": "string",
                            "description": "The name of the binary executable.\nDefaults to the target name with any `.` replaced with a `-`."
                        },
                        "needs": {
                            "type": "array",
                            "items": {
                                "type": "string",
                                "description": "Build target identifier of target to build before the executable's modules.\n\nFormat: `<target>[:<facet>]*`, where:\n- `<target>` is of the form `@<package>`, `@<package>/<targetName>`, +<module>` or `@<package>/+<module>`,\n- `<package>` may be empty to reference the default package,\n- `<facet>` is the name of a target facet."
                            },
                            "default": [],
                            "description": "Build target identifiers of targets to build before the executable's modules.\n\nFormat: `<target>[:<facet>]*`, where:\n- `<target>` is of the form `@<package>`, `@<package>/<targetName>`, +<module>` or `@<package>/+<module>`,\n- `<package>` may be empty to reference the default package,\n- `<facet>` is the name of a target facet."
                        },
                        "supportInterpreter": {
                            "type": "boolean",
                            "default": false,
                            "description": "Enables the executable to interpret Lean files (e.g., via `Lean.Elab.runFrontend`) by exposing symbols within the  executable to the Lean interpreter.\n\nImplementation-wise, on Windows, the Lean shared libraries are linked to the executable and, on other systems, the executable is linked with `-rdynamic`. This increases the size of the binary on Linux and, on Windows, requires `libInit_shared.dll` and `libleanshared.dll` to  be co-located with the executable or part of `PATH` (e.g., via `lake exe`). Thus, this feature should only be enabled when necessary."
                        }
                    },
                    "required": [
                        "name"
                    ],
                    "x-taplo": {
                        "initKeys": [
                            "name"
                        ]
                    }
                }
            ]
        },
        "inputFileConfig": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of the input file."
                },
                "path": {
                    "type": "string",
                    "description": "The path to the input file (relative to the package root).\n\nDefaults to the name of the target."
                },
                "text": {
                    "type": "boolean",
                    "default": false,
                    "description": "Whether this is a text file.\nIf so, Lake normalize line endings for its trace.\nThis avoids rebuilds across platforms with different line endings."
                }
            },
            "required": [
                "name"
            ],
            "x-taplo": {
                "initKeys": [
                    "name"
                ]
            }
        },
        "inputDirConfig": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of the input directory."
                },
                "path": {
                    "type": "string",
                    "description": "The path to the input directory (relative to the package root).\n\nDefaults to the name of the target."
                },
                "text": {
                    "type": "boolean",
                    "default": false,
                    "description": "Whether the directory is composed of text files.\nIf so, Lake normalize line endings for their traces.\nThis avoids rebuilds across platforms with different line endings."
                },
                "filter": {
                    "type": [
                        "string",
                        "object"
                    ],
                    "default": "*",
                    "description": "Includes only the files from the directory whose paths satisfy this pattern.\n\nFormat: Either `\"*\"`, or a recursive object with one of the following properties at every layer:\n- `path`: String pattern matching the path.\n- `extension`: String pattern matching the extension of the file in the path.\n- `fileName`: String pattern matching the name of the file in the path.\n- `not`: Negate a path pattern.\n- `any`: Match any of an array of path patterns.\n- `all`: Match all of an array of path patterns.\n\nString patterns have the following format: Either `\"*\"`, an array of all strings that are a match, or a recursive object with one of the following properties at every layer:\n- `startsWith`: Denotes a prefix string of all strings that are a match.\n- `endsWith`: Denotes a suffix string of all strings that are a match.\n- `not`: Negate a string pattern.\n- `any`: Match any of an array of string patterns.\n- `all`: Match all of an array of string patterns."
                }
            },
            "required": [
                "name"
            ],
            "x-taplo": {
                "initKeys": [
                    "name"
                ]
            }
        },
        "dependencyConfig": {
            "type": "object",
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The package name of the dependency.\nThis name must match the one declared in its configuration file, as that name is used to index its target data types. For this reason, the package name must also be unique across packages in the dependency graph."
                },
                "path": {
                    "type": "string",
                    "description": "A dependency on the local filesystem, specified by its path."
                },
                "git": {
                    "type": ["string", "object"],
                    "default": "",
                    "description": "A dependency in a Git repository, specified by its URL."
                },
                "subDir": {
                    "type": "string",
                    "description": "The subdirectory of a Git repository (as specified by `git`) that contains the package's source code."
                },
                "rev": {
                    "type": "string",
                    "description": "For Git dependencies, this field specifies the Git revision, which may be a branch name, a tag name, or a specific hash."
                },
                "scope": {
                    "type": "string",
                    "description": "An additional qualifier used to distinguish packages of the same name in a Lake registry. On Reservoir, this is the package owner."
                }
            },
            "required": [
                "name"
            ],
            "x-taplo": {
                "initKeys": [
                    "name",
                    "git",
                    "rev",
                    "scope"
                ]
            }
        }
    },
    "allOf": [
        {
            "$ref": "#/definitions/leanConfig"
        },
        {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of the package."
                },
                "version": {
                    "type": "string",
                    "description": "The package version. Versions have the form:\n\n``` v!\"<major>.<minor>.<patch>[-<specialDescr>]\" ``` \nA version with a `-` suffix is considered a \"prerelease\".\n\nLake suggest the following guidelines for incrementing versions:\n\n* **Major version increment** *(e.g., v1.3.0 → v2.0.0)* Indicates significant breaking changes in the package.\nPackage users are not expected to update to the new version without manual intervention.\n\n* **Minor version increment** *(e.g., v1.3.0 → v1.4.0)* Denotes notable changes that are expected to be generally backwards compatible.\nPackage users are expected to update to this version automatically and should be able to fix any breakages and/or warnings easily.\n\n* **Patch version increment** *(e.g., v1.3.0 → v1.3.1)* Reserved for bug fixes and small touchups.\nPackage users are expected to update automatically and should not expect significant breakage, except in the edge case of users relying on the behavior of patched bugs.\n\n**Note that backwards-incompatible changes may occur at any version increment.** The is because the current nature of Lean (e.g., transitive imports, rich metaprogramming, reducibility in proofs), makes it infeasible to define a completely stable interface for a package.\nInstead, the different version levels indicate a change's intended significance and how difficult migration is expected to be.\n\nVersions of form the `0.x.x` are considered development versions prior to first official release. Like prerelease, they are not expected to closely follow the above guidelines.\n\nPackages without a defined version default to `0.0.0`."
                },
                "versionTags": {
                    "type": [
                        "string",
                        "object",
                        "array"
                    ],
                    "default": "*",
                    "items": {
                        "type": "string"
                    },
                    "description": "Git tags of this package's repository that should be treated as versions.\nPackage indices (e.g., Reservoir) can make use of this information to determine the Git revisions corresponding to released versions.\n\nDefaults to tags that are \"version-like\".\nThat is, start with a `v` followed by a digit.\n\nFormat: Either `\"*\"`, an array of all version strings that are a match, or a recursive object with one of the following properties at every layer:\n- `preset`: Denotes the name of a preset-matcher as a string. Currently, the only preset-mater is `verLike`.\n- `startsWith`: Denotes a prefix string of all version strings that are a match.\n- `endsWith`: Denotes a suffix string of all version strings that are a match.\n- `not`: Negate a version string pattern.\n- `any`: Match any of an array of version string patterns.\n- `all`: Match all of an array of version string patterns."
                },
                "description": {
                    "type": "string",
                    "description": "A short description for the package (e.g., for Reservoir)."
                },
                "keywords": {
                    "type": "array",
                    "items": {
                        "type": "string",
                        "description": "Custom keyword associated with the package.\nReservoir can make use of a package's keywords to group related packages together and make it easier for users to discover them.\n\nGood keywords include the domain (e.g., `math`, `software-verification`, `devtool`), specific subtopics (e.g., `topology`,  `cryptology`), and significant implementation details (e.g., `dsl`, `ffi`, `cli`).\nFor instance, Lake's keywords could be `devtool`, `cli`, `dsl`, `package-manager`, and `build-system`."
                    },
                    "default": [],
                    "description": "Custom keywords associated with the package.\nReservoir can make use of a package's keywords to group related packages together and make it easier for users to discover them.\n\nGood keywords include the domain (e.g., `math`, `software-verification`, `devtool`), specific subtopics (e.g., `topology`,  `cryptology`), and significant implementation details (e.g., `dsl`, `ffi`, `cli`).\nFor instance, Lake's keywords could be `devtool`, `cli`, `dsl`, `package-manager`, and `build-system`."
                },
                "homepage": {
                    "type": "string",
                    "description": "A URL to information about the package.\n\nReservoir will already include a link to the package's GitHub repository (if the package is sourced from there). Thus, users are advised to specify something else for this (if anything)."
                },
                "license": {
                    "type": "string",
                    "description": "The package's license (if one).\nShould be a valid [SPDX License Expression][1].\n\nReservoir requires that packages uses an OSI-approved license to be included in its index, and currently only supports single identifier SPDX expressions. For, a list of OSI-approved SPDX license identifiers, see the [SPDX LIcense List][2].\n\n[1]: https://spdx.github.io/spdx-spec/v3.0/annexes/SPDX-license-expressions/ [2]: https://spdx.org/licenses/"
                },
                "licenseFiles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "default": [
                        "LICENSE"
                    ],
                    "description": "Files containing licensing information for the package.\n\nThese should be the license files that users are expected to include when distributing package sources, which may be more then one file for some licenses.\nFor example, the Apache 2.0 license requires the reproduction of a `NOTICE` file along with the license (if such a file exists)."
                },
                "readmeFile": {
                    "type": "string",
                    "default": "README.md",
                    "description": "The path to the package's README.\n\nA README should be a Markdown file containing an overview of the package.\nReservoir displays the rendered HTML of this file on a package's page.\nA nonstandard location can be used to provide a different README for Reservoir and GitHub."
                },
                "reservoir": {
                    "type": "boolean",
                    "default": true,
                    "description": "Whether Reservoir should include the package in its index.\nWhen set to `false`, Reservoir will not add the package to its index and will remove it if it was already there (when Reservoir is next updated)."
                },
                "libPrefixOnWindows": {
                    "type": "boolean",
                    "default": false,
                    "description": "Whether native libraries (of this package) should be prefixed with `lib` on Windows.\n\nUnlike Unix, Windows does not require native libraries to start with `lib` and, by convention, they usually do not. However, for consistent naming across all platforms, users may wish to enable this."
                },
                "allowImportAll": {
                    "type": "boolean",
                    "default": false,
                    "description": "Whether downstream packages can `import all` modules of this package.\n\nIf enabled, downstream users will be able to access the `private` internals of modules, including definition bodies not marked as `@[expose]`. This may also, in the future, prevent compiler optimization which rely on `private` definitions being inaccessible outside their own package."
                },
                "enableArtifactCache": {
                    "type": "boolean",
                    "description": "Whether to enables Lake's local, offline artifact cache for the package.\n\nArtifacts (i.e., build products) of packages will be shared across local copies by storing them in a cache associated with the Lean toolchain.\nThis can significantly reduce initial build times and disk space usage when working with multiple copies of large projects or large dependencies.\n\nAs a caveat, build targets which support the artifact cache will not be stored in their usual location within the build directory. Thus, projects with custom build scripts that rely on specific location of artifacts may wish to disable this feature.\n\nIf not set,   If `none` (the default), this will fallback to (in order):\n* The `LAKE_ARTIFACT_CACHE` environment variable (if set)\n* The workspace root's `enableArtifactCache` configuration (if set and this package is a dependency)\n* Lake's default: `false`"
                },
                "restoreAllArtifacts": {
                    "type": "boolean",
                    "description": "Whether, when the local artifact cache is enabled, Lake should copy all cached artifacts into the build directory. This ensures the build results are available to external consumers who expect them in the build directory."
                },
                "srcDir": {
                    "type": "string",
                    "default": ".",
                    "description": "The directory containing the package's Lean source files.\nDefaults to the package's directory.\n\n(This will be passed to `lean` as the `-R` option.)"
                },
                "buildDir": {
                    "type": "string",
                    "default": ".lake/build",
                    "description": "The directory to which Lake should output the package's build results."
                },
                "leanLibDir": {
                    "type": "string",
                    "default": "lib/lean",
                    "description": "The build subdirectory to which Lake should output the package's binary Lean libraries (e.g., `.olean`, `.ilean` files)."
                },
                "nativeLibDir": {
                    "type": "string",
                    "default": "lib",
                    "description": "The build subdirectory to which Lake should output the package's native libraries (e.g., `.a`, `.so`, `.dll` files)."
                },
                "binDir": {
                    "type": "string",
                    "default": "bin",
                    "description": "The build subdirectory to which Lake should output the package's binary executable."
                },
                "irDir": {
                    "type": "string",
                    "default": "ir",
                    "description": "The build subdirectory to which Lake should output the package's intermediary results (e.g., `.c` and `.o` files)."
                },
                "packagesDir": {
                    "type": "string",
                    "default": ".lake/packages",
                    "description": "The directory to which Lake should download remote dependencies."
                },
                "extraDepTargets": {
                    "type": "array",
                    "items": {
                        "type": "string",
                        "description": "A target name to build whenever the package is used."
                    },
                    "default": [],
                    "description": "An array of target names to build whenever the package is used."
                },
                "precompileModules": {
                    "type": "boolean",
                    "default": "false",
                    "description": "Whether to compile each of the package's module into a native shared library that is loaded whenever the module is imported. This speeds up evaluation of metaprograms and enables the interpreter to run functions marked `@[extern]`."
                },
                "defaultTargets": {
                    "type": "array",
                    "items": {
                        "type": "string",
                        "description": "A name of a package target to build by default (i.e., on a bare `lake build` of the package)."
                    },
                    "default": [],
                    "description": "The names of the package's targets to build by default (i.e., on a bare `lake build` of the package)."
                },
                "moreGlobalServerArgs": {
                    "type": "array",
                    "items": {
                        "type": "string",
                        "description": "An additional argument to pass to the Lean language server launched by `lake serve`, both for this package and also for any packages browsed from this one in the same session."
                    },
                    "default": [],
                    "description": "Additional arguments to pass to the Lean language server launched by `lake serve`, both for this package and also for any packages browsed from this one in the same session."
                },
                "testDriver": {
                    "type": "string",
                    "description": "The name of the script, executable, or library by `lake test` when this package is the workspace root. To point to a definition in another package, use the syntax `<pkg>/<def>`.\n\nA script driver will be run by `lake test` with the arguments configured in `testDriverArgs` followed by any specified on the CLI (e.g., via  `lake lint -- <args>...`). An executable driver will be built and then run like a script. A library will just be built."
                },
                "testDriverArgs": {
                    "type": "array",
                    "items": {
                        "type": "string",
                        "description": "An argument to pass to the package's test driver."
                    },
                    "default": [],
                    "description": "Arguments to pass to the package's test driver.\nThese arguments will come before those passed on the command line via `lake test -- <args>...`."
                },
                "lintDriver": {
                    "type": "string",
                    "description": "The name of the script or executable used by `lake lint` when this package is the workspace root. To point to a definition in another package, use the syntax `<pkg>/<def>`.\n\nA script driver will be run by `lake lint` with the arguments configured in `lintDriverArgs` followed by any specified on the CLI (e.g., via  `lake lint -- <args>...`). An executable driver will be built and then run like a script."
                },
                "lintDriverArgs": {
                    "type": "array",
                    "items": {
                        "type": "string",
                        "description": "An argument to pass to the package's linter."
                    },
                    "default": [],
                    "description": "Arguments to pass to the package's linter.\nThese arguments will come before those passed on the command line via `lake lint -- <args>...`."
                },
                "releaseRepo": {
                    "type": "string",
                    "description": "The URL of the GitHub repository to upload and download releases of this package.\nIf not set, for downloads, Lake uses the URL the package was download from (if it is a dependency) and for uploads, uses `gh`'s default."
                },
                "buildArchive": {
                    "type": "string",
                    "description": "A custom name for the build archive for the GitHub cloud release.\nIf not set, Lake defaults to `{(pkg-)name}-{System.Platform.target}.tar.gz`."
                },
                "preferReleaseBuild": {
                    "type": "boolean",
                    "default": "false",
                    "description": "Whether to prefer downloading a prebuilt release (from GitHub) rather than building this package from the source when this package is used as a dependency."
                },
                "require": {
                    "type": "array",
                    "items": [
                        {
                            "$ref": "#/definitions/dependencyConfig"
                        }
                    ],
                    "description": "Dependencies of a package, each of which specifies both the name and the source of each package. There are three kinds of sources:\n\n* Reservoir, or an alternative package registry \n* Git repositories, which may be local paths or URLs \n* Local paths"
                },
                "lean_lib": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/leanLibConfig"
                    },
                    "description": "Library targets of a package."
                },
                "lean_exe": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/leanExeConfig"
                    },
                    "description": "Executable targets of a package."
                },
                "input_file": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/inputFileConfig"
                    },
                    "description": "Input files of a package."
                },
                "input_dir": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/inputDirConfig"
                    },
                    "description": "Input directories of a package."
                }
            },
            "required": [
                "name"
            ],
            "x-taplo": {
                "initKeys": [
                    "name"
                ]
            }
        }
    ]
}

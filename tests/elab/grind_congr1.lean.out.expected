[grind.debug.proof] fun h h_1 h_2 =>
      Classical.byContradiction fun h_3 =>
        id
          (Eq.mp
            (Eq.trans
              (Eq.symm
                (eq_true
                  (Eq.trans
                    (Eq.trans (Eq.symm h)
                      (eq_of_heq
                        (eq_of_heq
                            (eq_of_heq ((fun a a' e_1 => e_1 ▸ HEq.refl (f a)) a b h_2) ▸
                              (fun a_1 a' e_1 => e_1 ▸ HEq.refl (f a a_1)) 0 0 (Eq.refl 0)) ▸
                          (fun a_1 a' e_1 => e_1 ▸ HEq.refl (f a 0 a_1)) true true (Eq.refl true))))
                    h_1)))
              (eq_false h_3))
            True.intro)
[grind.debug.proof] fun h h_1 h_2 =>
      Classical.byContradiction fun h_3 =>
        id
          (Eq.mp
            (Eq.trans
              (Eq.symm
                (eq_true
                  (Eq.trans (Eq.trans (Eq.symm h) (eq_of_heq ((fun a_1 a' e_1 => e_1 ▸ HEq.refl (f a b a_1)) x y h_2)))
                    h_1)))
              (eq_false h_3))
            True.intro)
[grind.debug.proof] fun h h_1 h_2 h_3 =>
      Classical.byContradiction fun h_4 =>
        id
          (Eq.mp
            (Eq.trans
              (Eq.symm
                (eq_true
                  (Eq.trans
                    (Eq.trans (Eq.symm h)
                      (eq_of_heq
                        (eq_of_heq
                            (eq_of_heq ((fun a a' e_1 => e_1 ▸ HEq.refl (f a)) a c h_2) ▸
                              (fun a_1 a' e_1 => e_1 ▸ HEq.refl (f a a_1)) b b (Eq.refl b)) ▸
                          (fun a_1 a' e_1 => e_1 ▸ HEq.refl (f a b a_1)) x y h_3)))
                    h_1)))
              (eq_false h_4))
            True.intro)
private theorem ex1 : ∀ {x : Bool} {v₁ : Nat} {y : Bool} {v₂ : Nat} (f : {α : Type} → α → Nat → Bool → Nat)
  (a b c : Nat), f a b x = v₁ → f c b y = v₂ → a = c → x = y → v₁ = v₂ :=
fun {x} {v₁} {y} {v₂} f a b c => ex1._proof_1_1 f a b c
private theorem ex2 : ∀ (n1 n2 n3 : Nat) (v1 w1 v : Vector Nat n1) (w1' : Vector Nat n3) (v2 w2 w : Vector Nat n2),
  n1 ≍ n3 → v1 = w1 → w1 ≍ w1' → v2 ≍ w2 → w1' ++ w2 ≍ v ++ w → v1 ++ v2 ≍ v ++ w :=
fun n1 n2 n3 v1 w1 v w1' v2 w2 w => ex2._proof_1_3 n1 n2 n3 v1 w1 v w1' v2 w2 w

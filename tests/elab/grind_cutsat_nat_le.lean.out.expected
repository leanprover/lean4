[grind.debug.proof] Lean.Grind.intro_with_eq (x < y + z) (x + 1 ≤ y + z) (y + 1 < z → z + x < 3 * z)
      (Lean.Grind.Nat.lt_eq x (y + z)) fun h =>
      Lean.Grind.intro_with_eq (y + 1 < z) (y + 2 ≤ z) (z + x < 3 * z)
        (Eq.trans (Lean.Grind.Nat.lt_eq (y + 1) z)
          (id
            (Nat.Linear.ExprCnstr.eq_of_toNormPoly_eq (Lean.RArray.branch 1 (Lean.RArray.leaf y) (Lean.RArray.leaf z))
              { eq := false, lhs := ((Nat.Linear.Expr.var 0).add (Nat.Linear.Expr.num 1)).add (Nat.Linear.Expr.num 1),
                rhs := Nat.Linear.Expr.var 1 }
              { eq := false, lhs := (Nat.Linear.Expr.var 0).add (Nat.Linear.Expr.num 2), rhs := Nat.Linear.Expr.var 1 }
              (eagerReduce (Eq.refl true)))))
        fun h_1 =>
        Classical.byContradiction
          (Lean.Grind.intro_with_eq (¬z + x < 3 * z) (2 * z ≤ x) False
            (Eq.trans
              (congrArg Not
                (Eq.trans (Lean.Grind.Nat.lt_eq (z + x) (3 * z))
                  (id
                    (Nat.Linear.ExprCnstr.eq_of_toNormPoly_eq
                      (Lean.RArray.branch 1 (Lean.RArray.leaf x) (Lean.RArray.leaf z))
                      { eq := false,
                        lhs := ((Nat.Linear.Expr.var 1).add (Nat.Linear.Expr.var 0)).add (Nat.Linear.Expr.num 1),
                        rhs := Nat.Linear.Expr.mulL 3 (Nat.Linear.Expr.var 1) }
                      { eq := false, lhs := (Nat.Linear.Expr.var 0).add (Nat.Linear.Expr.num 1),
                        rhs := Nat.Linear.Expr.mulL 2 (Nat.Linear.Expr.var 1) }
                      (eagerReduce (Eq.refl true))))))
              (Eq.trans (Nat.not_le_eq (x + 1) (2 * z))
                (id
                  (Nat.Linear.ExprCnstr.eq_of_toNormPoly_eq
                    (Lean.RArray.branch 1 (Lean.RArray.leaf x) (Lean.RArray.leaf z))
                    { eq := false, lhs := (Nat.Linear.Expr.mulL 2 (Nat.Linear.Expr.var 1)).add (Nat.Linear.Expr.num 1),
                      rhs := (Nat.Linear.Expr.var 0).add (Nat.Linear.Expr.num 1) }
                    { eq := false, lhs := Nat.Linear.Expr.mulL 2 (Nat.Linear.Expr.var 1), rhs := Nat.Linear.Expr.var 0 }
                    (eagerReduce (Eq.refl true))))))
            fun h_2 =>
            id
              (let ctx :=
                Lean.RArray.branch 1 (Lean.RArray.leaf ↑x)
                  (Lean.RArray.branch 2 (Lean.RArray.leaf ↑y) (Lean.RArray.leaf ↑z));
              let p_1 := Poly.num 12;
              let p_2 := Poly.add (-1) 2 (Poly.add 1 1 (Poly.num 2));
              let p_3 := Poly.add (-1) 2 (Poly.add (-1) 1 (Poly.add 1 0 (Poly.num 1)));
              let p_4 := Poly.add 2 1 (Poly.add (-1) 0 (Poly.num 4));
              let p_5 := Poly.add 2 2 (Poly.add (-1) 0 (Poly.num 0));
              let p_6 := Poly.add (-2) 1 (Poly.add 1 0 (Poly.num 2));
              let e_1 := Expr.var 2;
              let e_2 := Expr.var 0;
              let e_3 := (Expr.var 1).add (Expr.var 2);
              let e_4 := Expr.mulL 2 (Expr.var 2);
              let e_5 := (Expr.var 1).add (Expr.num 2);
              let e_6 := (Expr.var 0).add (Expr.num 1);
              le_unsat ctx p_1 (eagerReduce (Eq.refl true))
                (le_combine ctx p_6 p_4 p_1 (eagerReduce (Eq.refl true))
                  (le_combine ctx p_3 p_5 p_6 (eagerReduce (Eq.refl true))
                    (le_norm_expr ctx e_6 e_3 p_3 (eagerReduce (Eq.refl true))
                      (Nat.ToInt.of_le (Nat.ToInt.add_congr (Eq.refl ↑x) (Nat.ToInt.natCast_ofNat 1))
                        (Nat.ToInt.add_congr (Eq.refl ↑y) (Eq.refl ↑z)) h))
                    (le_norm_expr ctx e_4 e_2 p_5 (eagerReduce (Eq.refl true))
                      (Nat.ToInt.of_le (Nat.ToInt.mul_congr (Nat.ToInt.natCast_ofNat 2) (Eq.refl ↑z)) (Eq.refl ↑x)
                        h_2)))
                  (le_combine ctx p_2 p_5 p_4 (eagerReduce (Eq.refl true))
                    (le_norm_expr ctx e_5 e_1 p_2 (eagerReduce (Eq.refl true))
                      (Nat.ToInt.of_le (Nat.ToInt.add_congr (Eq.refl ↑y) (Nat.ToInt.natCast_ofNat 2)) (Eq.refl ↑z) h_1))
                    (le_norm_expr ctx e_4 e_2 p_5 (eagerReduce (Eq.refl true))
                      (Nat.ToInt.of_le (Nat.ToInt.mul_congr (Nat.ToInt.natCast_ofNat 2) (Eq.refl ↑z)) (Eq.refl ↑x)
                        h_2))))))
private theorem ex1 : ∀ (x y z : Nat), x < y + z → y + 1 < z → z + x < 3 * z :=
fun x y z => ex1._proof_1_1 x y z
private theorem ex2 : ∀ {p : Prop} (x y z : Nat), x < y + z → y + 1 < z → (p ↔ z + x < 3 * z) → p :=
fun {p} x y z => ex2._proof_1_1 x y z
private theorem ex3 : ∀ (x y : Nat),
  27 ≤ 13 * x + 11 * y → 13 * x + 11 * y ≤ 30 → 7 * y ≤ 9 * x + 10 → 9 * x ≤ 4 + 7 * y → False :=
fun x y => ex3._proof_1_1 x y

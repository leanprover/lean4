[Compiler.IR] [reset_reuse]
    def f (x_1 : obj) : obj :=
      case x_1 : obj of
      Prod.mk →
        let x_2 : tobj := proj[0] x_1;
        let x_3 : tobj := proj[1] x_1;
        let x_5 : tobj := reset[2] x_1;
        let x_4 : obj := reuse x_5 in ctor_0[Prod.mk] x_3 x_2;
        ret x_4
[Compiler.IR] [reset_reuse]
    def Sigma.toProd._redArg (x_1 : obj) : obj :=
      case x_1 : obj of
      Sigma.mk →
        let x_2 : tobj := proj[0] x_1;
        let x_3 : tobj := proj[1] x_1;
        let x_5 : tobj := reset[2] x_1;
        let x_4 : obj := reuse x_5 in ctor_0[Prod.mk] x_2 x_3;
        ret x_4
    def Sigma.toProd (x_1 : ◾) (x_2 : ◾) (x_3 : obj) : obj :=
      let x_4 : obj := Sigma.toProd._redArg x_3;
      ret x_4
[Compiler.IR] [reset_reuse]
    def foo (x_1 : tobj) : tobj :=
      case x_1 : tobj of
      List.nil →
        ret x_1
      List.cons →
        let x_2 : tobj := proj[0] x_1;
        case x_2 : obj of
        Prod.mk →
          let x_3 : tobj := proj[1] x_1;
          let x_9 : tobj := reset[2] x_1;
          let x_4 : tobj := proj[0] x_2;
          let x_5 : tobj := proj[1] x_2;
          let x_6 : tobj := foo x_3;
          let x_7 : obj := reuse x_9 in ctor_1[List.cons] x_4 x_6;
          ret x_7

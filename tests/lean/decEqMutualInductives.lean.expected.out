[Elab.Deriving.decEq] 
    [mutual
       def decEqTree✝ (x✝ : @Tree✝) (x✝¹ : @Tree✝) : Decidable✝ (x✝ = x✝¹) :=
         match x✝, x✝¹ with
         | @Tree.node a✝, @Tree.node b✝ =>
           let inst✝ := decEqListTree✝ @a✝ @b✝;
           if h✝ : @a✝ = @b✝ then by subst h✝; exact isTrue✝ rfl✝
           else isFalse✝ (by intro n✝; injection n✝; apply h✝ _; assumption)
       termination_by structural x✝
       def decEqListTree✝ (x✝² : @ListTree✝) (x✝³ : @ListTree✝) : Decidable✝ (x✝² = x✝³) :=
         if h✝¹ : ListTree.ctorIdx✝ x✝² = ListTree.ctorIdx✝ x✝³ then
           ListTree.match_on_same_ctor✝ x✝² x✝³ h✝¹ (@fun => isTrue✝¹ rfl✝¹)
             @fun a✝¹ a✝² b✝¹ b✝² =>
               let inst✝¹ := decEqTree✝ @a✝¹ @b✝¹;
               if h✝² : @a✝¹ = @b✝¹ then by subst h✝²;
                 exact
                   let inst✝² := decEqListTree✝ @a✝² @b✝²;
                   if h✝³ : @a✝² = @b✝² then by subst h✝³; exact isTrue✝² rfl✝²
                   else isFalse✝¹ (by intro n✝¹; injection n✝¹; apply h✝³ _; assumption)
               else isFalse✝² (by intro n✝²; injection n✝²; apply h✝² _; assumption)
         else isFalse✝³ (fun h'✝ => h✝¹ (congrArg✝ ListTree.ctorIdx✝ h'✝))
       termination_by structural x✝²
     end,
     instance : DecidableEq✝ (@ListTree✝) :=
       decEqListTree✝]
[Elab.Deriving.decEq] 
    [mutual
       def decEqFoo₁✝ (x✝ : @Foo₁✝) (x✝¹ : @Foo₁✝) : Decidable✝ (x✝ = x✝¹) :=
         if h✝ : Foo₁.ctorIdx✝ x✝ = Foo₁.ctorIdx✝ x✝¹ then
           Foo₁.match_on_same_ctor✝ x✝ x✝¹ h✝ (@fun => isTrue✝ rfl✝)
             @fun a✝ b✝ =>
               let inst✝ := decEqFoo₂✝ @a✝ @b✝;
               if h✝¹ : @a✝ = @b✝ then by subst h✝¹; exact isTrue✝¹ rfl✝¹
               else isFalse✝ (by intro n✝; injection n✝; apply h✝¹ _; assumption)
         else isFalse✝¹ (fun h'✝ => h✝ (congrArg✝ Foo₁.ctorIdx✝ h'✝))
       termination_by structural x✝
       def decEqFoo₂✝ (x✝² : @Foo₂✝) (x✝³ : @Foo₂✝) : Decidable✝ (x✝² = x✝³) :=
         match x✝², x✝³ with
         | @Foo₂.foo₂ a✝¹, @Foo₂.foo₂ b✝¹ =>
           let inst✝¹ := decEqFoo₃✝ @a✝¹ @b✝¹;
           if h✝² : @a✝¹ = @b✝¹ then by subst h✝²; exact isTrue✝² rfl✝²
           else isFalse✝² (by intro n✝¹; injection n✝¹; apply h✝² _; assumption)
       termination_by structural x✝²
       def decEqFoo₃✝ (x✝⁴ : @Foo₃✝) (x✝⁵ : @Foo₃✝) : Decidable✝ (x✝⁴ = x✝⁵) :=
         match x✝⁴, x✝⁵ with
         | @Foo₃.foo₃ a✝², @Foo₃.foo₃ b✝² =>
           let inst✝² := decEqFoo₁✝ @a✝² @b✝²;
           if h✝³ : @a✝² = @b✝² then by subst h✝³; exact isTrue✝³ rfl✝³
           else isFalse✝³ (by intro n✝²; injection n✝²; apply h✝³ _; assumption)
       termination_by structural x✝⁴
     end,
     instance : DecidableEq✝ (@Foo₁✝) :=
       decEqFoo₁✝]

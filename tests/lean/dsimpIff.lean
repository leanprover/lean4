/-
Copyright (c) 2023 Thomas Murrills. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Thomas Murrills
-/

/-! # Allow `dsimp` to utilize `Iff` `rfl` theorems

These tests ensure that `dsimp` is able to utilize `rfl` proofs of `Iff` (`↔`).
`rfl` proofs are those generated by `Iff.rfl`, `Iff.refl`, and `Iff.symm`, in analogy to `Eq`.

See issue #2678.
-/


/-! # Setup -/

/-- Different kinds of tests. Used to distinguish wrappers so that we have multiple different
things to rewrite, and can restrict the applicability of our test `@[simp]` theorems. -/
inductive TestKind where
| /-- Test `Iff.rfl`  -/ rfl
| /-- Test `Iff.refl` -/ refl
| /-- Test `Iff.symm` -/ symm
| /-- Test `propext`  -/ propext (proof : TestKind)
  /-- Test that applications of `rfl` proofs are `rfl` proofs -/
| application
  /-- Test that all of these rules behave well together -/
| composite (marker : Nat)

/-- A wrapper for a `Prop` that we hope is rewritten by `dsimp`.

The first argument, which is either `.rfl`, `.refl`, `.symm`, `.propext (proof : TestKind)` or
`.application true`/`.application false`, allows us to distinguish its usage in different tests. -/
def w (_ : TestKind) : Prop → Prop | p => p


/-! # Tests

Each of the following uses of `dsimp` previously made no progress on the goal.
Now, `dsimp` should rewrite the goal to `a` using the preceding `@[simp]` theorem.
-/


/-! ## `Iff.rfl` -/

@[simp] theorem w_rfl : w .rfl a ↔ a := Iff.rfl

example : w .rfl a := by dsimp


/-! ## `Iff.refl` -/

@[simp] theorem w_refl : w .refl a ↔ a := Iff.refl a

example : w .refl a := by dsimp


/-! ## `Iff.symm` -/

@[simp] theorem w_symm : w .symm a ↔ a := Iff.symm Iff.rfl

example : w .symm a := by dsimp


/-! ## Application

Applications of `rfl` theorems should be considered `rfl` theorems.
-/

theorem w_app_internal (x y z : Nat) : w .application a ↔ a := Iff.rfl

@[simp] theorem w_app : w .application a ↔ a := w_app_internal 0 0 0

example : w .application a := by dsimp


/-! ## `propext`

Note that we've implicitly been testing recognition of `propext` the whole time, since `@[simp]`
preprocesses our theorems by wrapping them in `propext`. Here we test a direct usage.
-/

@[simp] theorem w_propext_rfl : w (.propext .rfl) a = a := propext Iff.rfl

example : w (.propext .rfl) a := by dsimp

@[simp] theorem w_propext_refl : w (.propext .refl) a = a := propext (Iff.refl a)

example : w (.propext .rfl) a := by dsimp

@[simp] theorem w_propext_symm : w (.propext .symm) a = a := propext (Iff.symm Iff.rfl)

example : w (.propext .symm) a := by dsimp

@[simp] theorem w_propext_app : w (.propext .application) a = a := propext (w_app_internal 0 0 0)

example : w (.propext .application) a := by dsimp

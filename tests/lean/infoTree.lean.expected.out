[Elab.info] command @ ⟨11, 0⟩-⟨11, 31⟩ @ Lean.Elab.Command.elabSetOption
  [.] (Command.set_option "set_option" `trace.Elab.info) @ ⟨11, 0⟩-⟨11, 26⟩
[Elab.info] command @ ⟨13, 0⟩-⟨15, 6⟩ @ Lean.Elab.Command.elabDeclaration
  Nat : Type @ ⟨13, 11⟩-⟨13, 14⟩ @ Lean.Elab.Term.elabIdent
    [.] `Nat : some Sort.{?_uniq} @ ⟨13, 11⟩-⟨13, 14⟩
    Nat : Type @ ⟨13, 11⟩-⟨13, 14⟩
  x (isBinder := true) : Nat @ ⟨13, 7⟩-⟨13, 8⟩
  Nat × Nat : Type @ ⟨13, 18⟩-⟨13, 27⟩ @ «_aux_Init_Notation___macroRules_term_×__1»
    Macro expansion
    Nat × Nat
    ===>
    Prod✝ Nat Nat
      Nat × Nat : Type @ ⟨13, 18⟩†-⟨13, 27⟩ @ Lean.Elab.Term.elabApp
        [.] `Prod._@.infoTree._hyg.35 : some Sort.{?_uniq} @ ⟨13, 18⟩†-⟨13, 27⟩†
        Prod : Type → Type → Type @ ⟨13, 18⟩†-⟨13, 27⟩†
        Nat : Type @ ⟨13, 18⟩-⟨13, 21⟩ @ Lean.Elab.Term.elabIdent
          [.] `Nat : some Type.{?_uniq} @ ⟨13, 18⟩-⟨13, 21⟩
          Nat : Type @ ⟨13, 18⟩-⟨13, 21⟩
        Nat : Type @ ⟨13, 24⟩-⟨13, 27⟩ @ Lean.Elab.Term.elabIdent
          [.] `Nat : some Type.{?_uniq} @ ⟨13, 24⟩-⟨13, 27⟩
          Nat : Type @ ⟨13, 24⟩-⟨13, 27⟩
  f (isBinder := true) : Nat → Nat × Nat @ ⟨13, 4⟩-⟨13, 5⟩
  x (isBinder := true) : Nat @ ⟨13, 7⟩-⟨13, 8⟩
  let y := (x, x);
  id y : Nat × Nat @ ⟨14, 2⟩-⟨15, 6⟩ @ Lean.Elab.Term.elabLetDecl
    Nat × Nat : Type @ ⟨14, 6⟩†-⟨14, 7⟩† @ Lean.Elab.Term.elabHole
    (x, x) : Nat × Nat @ ⟨14, 11⟩-⟨14, 17⟩ @ Lean.Elab.Term.elabAnonymousCtor
      Macro expansion
      ⟨x, x⟩
      ===>
      Prod.mk✝ x x
        (x, x) : Nat × Nat @ ⟨14, 11⟩†-⟨14, 16⟩ @ Lean.Elab.Term.elabApp
          [.] `Prod.mk._@._internal._hyg.0 : some Prod.{0 0} Nat Nat @ ⟨14, 11⟩†-⟨14, 17⟩†
          @Prod.mk : {α β : Type} → α → β → α × β @ ⟨14, 11⟩†-⟨14, 17⟩†
          x : Nat @ ⟨14, 12⟩-⟨14, 13⟩ @ Lean.Elab.Term.elabIdent
            [.] `x : some ?_uniq @ ⟨14, 12⟩-⟨14, 13⟩
            x : Nat @ ⟨14, 12⟩-⟨14, 13⟩
          x : Nat @ ⟨14, 15⟩-⟨14, 16⟩ @ Lean.Elab.Term.elabIdent
            [.] `x : some ?_uniq @ ⟨14, 15⟩-⟨14, 16⟩
            x : Nat @ ⟨14, 15⟩-⟨14, 16⟩
    y (isBinder := true) : Nat × Nat @ ⟨14, 6⟩-⟨14, 7⟩
    id y : Nat × Nat @ ⟨15, 2⟩-⟨15, 6⟩ @ Lean.Elab.Term.elabApp
      [.] `id : some Prod.{0 0} Nat Nat @ ⟨15, 2⟩-⟨15, 4⟩
      @id : {α : Type} → α → α @ ⟨15, 2⟩-⟨15, 4⟩
      y : Nat × Nat @ ⟨15, 5⟩-⟨15, 6⟩ @ Lean.Elab.Term.elabIdent
        [.] `y : some ?_uniq @ ⟨15, 5⟩-⟨15, 6⟩
        y : Nat × Nat @ ⟨15, 5⟩-⟨15, 6⟩
  f (isBinder := true) : Nat → Nat × Nat @ ⟨13, 4⟩-⟨13, 5⟩
[Elab.info] command @ ⟨17, 0⟩-⟨19, 8⟩ @ Lean.Elab.Command.elabDeclaration
  ∀ (x y : Nat), Bool → x + 0 = x : Prop @ ⟨17, 8⟩-⟨17, 44⟩ @ Lean.Elab.Term.elabDepArrow
    Nat : Type @ ⟨17, 15⟩-⟨17, 18⟩ @ Lean.Elab.Term.elabIdent
      [.] `Nat : some Sort.{?_uniq} @ ⟨17, 15⟩-⟨17, 18⟩
      Nat : Type @ ⟨17, 15⟩-⟨17, 18⟩
    x (isBinder := true) : Nat @ ⟨17, 9⟩-⟨17, 10⟩
    Nat : Type @ ⟨17, 15⟩-⟨17, 18⟩ @ Lean.Elab.Term.elabIdent
      [.] `Nat : some Sort.{?_uniq} @ ⟨17, 15⟩-⟨17, 18⟩
      Nat : Type @ ⟨17, 15⟩-⟨17, 18⟩
    y (isBinder := true) : Nat @ ⟨17, 11⟩-⟨17, 12⟩
    Bool → x + 0 = x : Prop @ ⟨17, 22⟩-⟨17, 44⟩ @ Lean.Elab.Term.elabDepArrow
      Bool : Type @ ⟨17, 27⟩-⟨17, 31⟩ @ Lean.Elab.Term.elabIdent
        [.] `Bool : some Sort.{?_uniq} @ ⟨17, 27⟩-⟨17, 31⟩
        Bool : Type @ ⟨17, 27⟩-⟨17, 31⟩
      b (isBinder := true) : Bool @ ⟨17, 23⟩-⟨17, 24⟩
      x + 0 = x : Prop @ ⟨17, 35⟩-⟨17, 44⟩ @ «_aux_Init_Notation___macroRules_term_=__2»
        Macro expansion
        x + 0 = x
        ===>
        binrel% Eq✝ (x + 0)x
          x + 0 = x : Prop @ ⟨17, 35⟩†-⟨17, 44⟩ @ Lean.Elab.Term.BinOp.elabBinRel
            [.] `Eq._@.infoTree._hyg.55 : none @ ⟨17, 35⟩†-⟨17, 44⟩†
            [.] `HAdd.hAdd._@.infoTree._hyg.57 : none @ ⟨17, 35⟩†-⟨17, 40⟩†
            x : Nat @ ⟨17, 35⟩-⟨17, 36⟩ @ Lean.Elab.Term.elabIdent
              [.] `x : none @ ⟨17, 35⟩-⟨17, 36⟩
              x : Nat @ ⟨17, 35⟩-⟨17, 36⟩
            0 : Nat @ ⟨17, 39⟩-⟨17, 40⟩ @ Lean.Elab.Term.elabNumLit
            x : Nat @ ⟨17, 43⟩-⟨17, 44⟩ @ Lean.Elab.Term.elabIdent
              [.] `x : none @ ⟨17, 43⟩-⟨17, 44⟩
              x : Nat @ ⟨17, 43⟩-⟨17, 44⟩
  h (isBinder := true) : ∀ (x y : Nat), Bool → x + 0 = x @ ⟨17, 4⟩-⟨17, 5⟩
  fun x y b => of_eq_true (eq_self x) : ∀ (x y : Nat), Bool → x + 0 = x @ ⟨18, 2⟩-⟨19, 8⟩ @ Lean.Elab.Term.elabFun
    Nat : Type @ ⟨18, 6⟩†-⟨18, 7⟩† @ Lean.Elab.Term.elabHole
    x (isBinder := true) : Nat @ ⟨18, 6⟩-⟨18, 7⟩
    Nat : Type @ ⟨18, 8⟩†-⟨18, 9⟩† @ Lean.Elab.Term.elabHole
    y (isBinder := true) : Nat @ ⟨18, 8⟩-⟨18, 9⟩
    Bool : Type @ ⟨18, 10⟩†-⟨18, 11⟩† @ Lean.Elab.Term.elabHole
    b (isBinder := true) : Bool @ ⟨18, 10⟩-⟨18, 11⟩
    Tactic @ ⟨18, 15⟩-⟨19, 8⟩
    (Term.byTactic "by" (Tactic.tacticSeq (Tactic.tacticSeq1Indented [(group (Tactic.simp "simp" [] [] [] [] []) [])])))
    before 
    x y : Nat
    b : Bool
    ⊢ x + 0 = x
    after no goals
      Tactic @ ⟨19, 4⟩-⟨19, 8⟩ @ Lean.Elab.Tactic.evalTacticSeq
      (Tactic.tacticSeq (Tactic.tacticSeq1Indented [(group (Tactic.simp "simp" [] [] [] [] []) [])]))
      before 
      x y : Nat
      b : Bool
      ⊢ x + 0 = x
      after no goals
        Tactic @ ⟨19, 4⟩-⟨19, 8⟩ @ Lean.Elab.Tactic.evalTacticSeq1Indented
        (Tactic.tacticSeq1Indented [(group (Tactic.simp "simp" [] [] [] [] []) [])])
        before 
        x y : Nat
        b : Bool
        ⊢ x + 0 = x
        after no goals
          Tactic @ ⟨19, 4⟩-⟨19, 8⟩ @ Lean.Elab.Tactic.evalSimp
          (Tactic.simp "simp" [] [] [] [] [])
          before 
          x y : Nat
          b : Bool
          ⊢ x + 0 = x
          after no goals
  h (isBinder := true) : ∀ (x y : Nat), Bool → x + 0 = x @ ⟨17, 4⟩-⟨17, 5⟩
[Elab.info] command @ ⟨21, 0⟩-⟨25, 10⟩ @ Lean.Elab.Command.elabDeclaration
  Nat → Nat → Bool → Nat : Type @ ⟨21, 9⟩-⟨21, 39⟩ @ Lean.Elab.Term.elabDepArrow
    Nat : Type @ ⟨21, 16⟩-⟨21, 19⟩ @ Lean.Elab.Term.elabIdent
      [.] `Nat : some Sort.{?_uniq} @ ⟨21, 16⟩-⟨21, 19⟩
      Nat : Type @ ⟨21, 16⟩-⟨21, 19⟩
    x (isBinder := true) : Nat @ ⟨21, 10⟩-⟨21, 11⟩
    Nat : Type @ ⟨21, 16⟩-⟨21, 19⟩ @ Lean.Elab.Term.elabIdent
      [.] `Nat : some Sort.{?_uniq} @ ⟨21, 16⟩-⟨21, 19⟩
      Nat : Type @ ⟨21, 16⟩-⟨21, 19⟩
    y (isBinder := true) : Nat @ ⟨21, 12⟩-⟨21, 13⟩
    Bool → Nat : Type @ ⟨21, 23⟩-⟨21, 39⟩ @ Lean.Elab.Term.elabDepArrow
      Bool : Type @ ⟨21, 28⟩-⟨21, 32⟩ @ Lean.Elab.Term.elabIdent
        [.] `Bool : some Sort.{?_uniq} @ ⟨21, 28⟩-⟨21, 32⟩
        Bool : Type @ ⟨21, 28⟩-⟨21, 32⟩
      b (isBinder := true) : Bool @ ⟨21, 24⟩-⟨21, 25⟩
      Nat : Type @ ⟨21, 36⟩-⟨21, 39⟩ @ Lean.Elab.Term.elabIdent
        [.] `Nat : some Sort.{?_uniq} @ ⟨21, 36⟩-⟨21, 39⟩
        Nat : Type @ ⟨21, 36⟩-⟨21, 39⟩
  f2 (isBinder := true) : Nat → Nat → Bool → Nat @ ⟨21, 4⟩-⟨21, 6⟩
  fun x y b =>
    let _discr := (x + y, x - y);
    match (x + y, x - y) with
    | (z, w) =>
      let z1 := z + w;
      z + z1 : Nat → Nat → Bool → Nat @ ⟨22, 2⟩-⟨25, 10⟩ @ Lean.Elab.Term.elabFun
    Nat : Type @ ⟨22, 6⟩†-⟨22, 7⟩† @ Lean.Elab.Term.elabHole
    x (isBinder := true) : Nat @ ⟨22, 6⟩-⟨22, 7⟩
    Nat : Type @ ⟨22, 8⟩†-⟨22, 9⟩† @ Lean.Elab.Term.elabHole
    y (isBinder := true) : Nat @ ⟨22, 8⟩-⟨22, 9⟩
    Bool : Type @ ⟨22, 10⟩†-⟨22, 11⟩† @ Lean.Elab.Term.elabHole
    b (isBinder := true) : Bool @ ⟨22, 10⟩-⟨22, 11⟩
    let _discr := (x + y, x - y);
    match (x + y, x - y) with
    | (z, w) =>
      let z1 := z + w;
      z + z1 : Nat @ ⟨23, 4⟩-⟨25, 10⟩ @ Lean.Elab.Term.elabLetDecl
      Macro expansion
      let (z, w) := (x + y, x - y)
      let z1 := z + w
      z + z1
      ===>
      match (x + y, x - y) with
      | (z, w) =>
        let z1 := z + w
        z + z1
        let _discr := (x + y, x - y);
        match (x + y, x - y) with
        | (z, w) =>
          let z1 := z + w;
          z + z1 : Nat @ ⟨23, 4⟩†-⟨25, 10⟩ @ Lean.Elab.Term.elabMatch
          Macro expansion
          match (x + y, x - y) with
          | (z, w) =>
            let z1 := z + w
            z + z1
          ===>
          let _discr✝ := (x + y, x - y);
          match _discr✝ with
          | (z, w) =>
            let z1 := z + w
            z + z1
            let _discr := (x + y, x - y);
            match (x + y, x - y) with
            | (z, w) =>
              let z1 := z + w;
              z + z1 : Nat @ ⟨23, 4⟩†-⟨25, 10⟩ @ Lean.Elab.Term.elabLetDecl
              Nat × Nat : Type @ ⟨23, 4⟩†-⟨25, 10⟩† @ Lean.Elab.Term.elabHole
              (x + y, x - y) : Nat × Nat @ ⟨23, 18⟩-⟨23, 32⟩ @ Lean.Elab.Term.expandParen
                Macro expansion
                (x + y, x - y)
                ===>
                Prod.mk✝ (x + y) (x - y)
                  (x + y, x - y) : Nat × Nat @ ⟨23, 18⟩†-⟨23, 31⟩ @ Lean.Elab.Term.elabApp
                    [.] `Prod.mk._@.infoTree._hyg.88 : some ?_uniq @ ⟨23, 18⟩†-⟨23, 32⟩†
                    @Prod.mk : {α β : Type} → α → β → α × β @ ⟨23, 18⟩†-⟨23, 32⟩†
                    x + y : Nat @ ⟨23, 19⟩-⟨23, 24⟩ @ «_aux_Init_Notation___macroRules_term_+__2»
                      Macro expansion
                      x + y
                      ===>
                      binop% HAdd.hAdd✝ x y
                        x + y : Nat @ ⟨23, 19⟩†-⟨23, 24⟩ @ Lean.Elab.Term.BinOp.elabBinOp
                          [.] `HAdd.hAdd._@.infoTree._hyg.91 : none @ ⟨23, 19⟩†-⟨23, 24⟩†
                          x : Nat @ ⟨23, 19⟩-⟨23, 20⟩ @ Lean.Elab.Term.elabIdent
                            [.] `x : none @ ⟨23, 19⟩-⟨23, 20⟩
                            x : Nat @ ⟨23, 19⟩-⟨23, 20⟩
                          y : Nat @ ⟨23, 23⟩-⟨23, 24⟩ @ Lean.Elab.Term.elabIdent
                            [.] `y : none @ ⟨23, 23⟩-⟨23, 24⟩
                            y : Nat @ ⟨23, 23⟩-⟨23, 24⟩
                    x - y : Nat @ ⟨23, 26⟩-⟨23, 31⟩ @ «_aux_Init_Notation___macroRules_term_-__2»
                      Macro expansion
                      x - y
                      ===>
                      binop% HSub.hSub✝ x y
                        x - y : Nat @ ⟨23, 26⟩†-⟨23, 31⟩ @ Lean.Elab.Term.BinOp.elabBinOp
                          [.] `HSub.hSub._@.infoTree._hyg.96 : none @ ⟨23, 26⟩†-⟨23, 31⟩†
                          x : Nat @ ⟨23, 26⟩-⟨23, 27⟩ @ Lean.Elab.Term.elabIdent
                            [.] `x : none @ ⟨23, 26⟩-⟨23, 27⟩
                            x : Nat @ ⟨23, 26⟩-⟨23, 27⟩
                          y : Nat @ ⟨23, 30⟩-⟨23, 31⟩ @ Lean.Elab.Term.elabIdent
                            [.] `y : none @ ⟨23, 30⟩-⟨23, 31⟩
                            y : Nat @ ⟨23, 30⟩-⟨23, 31⟩
              _discr✝ (isBinder := true) : Nat × Nat @ ⟨23, 4⟩†-⟨25, 10⟩†
              match (x + y, x - y) with
              | (z, w) =>
                let z1 := z + w;
                z + z1 : Nat @ ⟨23, 4⟩†-⟨25, 10⟩ @ Lean.Elab.Term.elabMatch
                [.] `Prod.mk._@.infoTree._hyg.102 : none @ ⟨23, 4⟩†-⟨25, 10⟩†
                @Prod.mk : {α : Type ?u} → {β : Type ?u} → α → β → α × β @ ⟨23, 4⟩†-⟨25, 10⟩†
                [.] `z : none @ ⟨23, 9⟩-⟨23, 10⟩
                [.] `w : none @ ⟨23, 12⟩-⟨23, 13⟩
                [.] `Prod.mk._@.infoTree._hyg.102 : some Prod.{0 0} Nat Nat @ ⟨23, 4⟩†-⟨25, 10⟩†
                [.] `z : some [mdata _patWithRef: ?_uniq] @ ⟨23, 9⟩-⟨23, 10⟩
                [.] `w : some [mdata _patWithRef: ?_uniq] @ ⟨23, 12⟩-⟨23, 13⟩
                (z, w) : Nat × Nat @ ⟨23, 4⟩†-⟨23, 13⟩
                  Nat : Type @ ⟨23, 4⟩†-⟨23, 13⟩†
                  Nat : Type @ ⟨23, 4⟩†-⟨23, 13⟩†
                  z (isBinder := true) : Nat @ ⟨23, 9⟩-⟨23, 10⟩
                  w (isBinder := true) : Nat @ ⟨23, 12⟩-⟨23, 13⟩
                let z1 := z + w;
                z + z1 : Nat @ ⟨24, 4⟩-⟨25, 10⟩ @ Lean.Elab.Term.elabLetDecl
                  Nat : Type @ ⟨24, 8⟩†-⟨24, 10⟩† @ Lean.Elab.Term.elabHole
                  z + w : Nat @ ⟨24, 14⟩-⟨24, 19⟩ @ «_aux_Init_Notation___macroRules_term_+__2»
                    Macro expansion
                    z + w
                    ===>
                    binop% HAdd.hAdd✝ z w
                      z + w : Nat @ ⟨24, 14⟩†-⟨24, 19⟩ @ Lean.Elab.Term.BinOp.elabBinOp
                        [.] `HAdd.hAdd._@.infoTree._hyg.114 : none @ ⟨24, 14⟩†-⟨24, 19⟩†
                        z : Nat @ ⟨24, 14⟩-⟨24, 15⟩ @ Lean.Elab.Term.elabIdent
                          [.] `z : none @ ⟨24, 14⟩-⟨24, 15⟩
                          z : Nat @ ⟨24, 14⟩-⟨24, 15⟩
                        w : Nat @ ⟨24, 18⟩-⟨24, 19⟩ @ Lean.Elab.Term.elabIdent
                          [.] `w : none @ ⟨24, 18⟩-⟨24, 19⟩
                          w : Nat @ ⟨24, 18⟩-⟨24, 19⟩
                  z1 (isBinder := true) : Nat @ ⟨24, 8⟩-⟨24, 10⟩
                  z + z1 : Nat @ ⟨25, 4⟩-⟨25, 10⟩ @ «_aux_Init_Notation___macroRules_term_+__2»
                    Macro expansion
                    z + z1
                    ===>
                    binop% HAdd.hAdd✝ z z1
                      z + z1 : Nat @ ⟨25, 4⟩†-⟨25, 10⟩ @ Lean.Elab.Term.BinOp.elabBinOp
                        [.] `HAdd.hAdd._@.infoTree._hyg.119 : none @ ⟨25, 4⟩†-⟨25, 10⟩†
                        z : Nat @ ⟨25, 4⟩-⟨25, 5⟩ @ Lean.Elab.Term.elabIdent
                          [.] `z : none @ ⟨25, 4⟩-⟨25, 5⟩
                          z : Nat @ ⟨25, 4⟩-⟨25, 5⟩
                        z1 : Nat @ ⟨25, 8⟩-⟨25, 10⟩ @ Lean.Elab.Term.elabIdent
                          [.] `z1 : none @ ⟨25, 8⟩-⟨25, 10⟩
                          z1 : Nat @ ⟨25, 8⟩-⟨25, 10⟩
  f2 (isBinder := true) : Nat → Nat → Bool → Nat @ ⟨21, 4⟩-⟨21, 6⟩
[Elab.info] command @ ⟨27, 0⟩-⟨28, 18⟩ @ Lean.Elab.Command.elabDeclaration
  Nat × Array (Array Nat) : Type @ ⟨27, 12⟩-⟨27, 35⟩ @ «_aux_Init_Notation___macroRules_term_×__1»
    Macro expansion
    Nat × Array (Array Nat)
    ===>
    Prod✝ Nat (Array (Array Nat))
      Nat × Array (Array Nat) : Type @ ⟨27, 12⟩†-⟨27, 35⟩ @ Lean.Elab.Term.elabApp
        [.] `Prod._@.infoTree._hyg.127 : some Sort.{?_uniq} @ ⟨27, 12⟩†-⟨27, 35⟩†
        Prod : Type → Type → Type @ ⟨27, 12⟩†-⟨27, 35⟩†
        Nat : Type @ ⟨27, 12⟩-⟨27, 15⟩ @ Lean.Elab.Term.elabIdent
          [.] `Nat : some Type.{?_uniq} @ ⟨27, 12⟩-⟨27, 15⟩
          Nat : Type @ ⟨27, 12⟩-⟨27, 15⟩
        Array (Array Nat) : Type @ ⟨27, 18⟩-⟨27, 35⟩ @ Lean.Elab.Term.elabApp
          [.] `Array : some Type.{?_uniq} @ ⟨27, 18⟩-⟨27, 23⟩
          Array : Type → Type @ ⟨27, 18⟩-⟨27, 23⟩
          Array Nat : Type @ ⟨27, 24⟩-⟨27, 35⟩ @ Lean.Elab.Term.expandParen
            Macro expansion
            (Array Nat)
            ===>
            Array Nat
              Array Nat : Type @ ⟨27, 25⟩-⟨27, 34⟩ @ Lean.Elab.Term.elabApp
                [.] `Array : some Type.{?_uniq} @ ⟨27, 25⟩-⟨27, 30⟩
                Array : Type → Type @ ⟨27, 25⟩-⟨27, 30⟩
                Nat : Type @ ⟨27, 31⟩-⟨27, 34⟩ @ Lean.Elab.Term.elabIdent
                  [.] `Nat : some Type.{?_uniq} @ ⟨27, 31⟩-⟨27, 34⟩
                  Nat : Type @ ⟨27, 31⟩-⟨27, 34⟩
  s (isBinder := true) : Nat × Array (Array Nat) @ ⟨27, 8⟩-⟨27, 9⟩
  Array Nat : Type @ ⟨27, 39⟩-⟨27, 48⟩ @ Lean.Elab.Term.elabApp
    [.] `Array : some Sort.{?_uniq} @ ⟨27, 39⟩-⟨27, 44⟩
    Array : Type → Type @ ⟨27, 39⟩-⟨27, 44⟩
    Nat : Type @ ⟨27, 45⟩-⟨27, 48⟩ @ Lean.Elab.Term.elabIdent
      [.] `Nat : some Type.{?_uniq} @ ⟨27, 45⟩-⟨27, 48⟩
      Nat : Type @ ⟨27, 45⟩-⟨27, 48⟩
  f3 (isBinder := true) : Nat × Array (Array Nat) → Array Nat @ ⟨27, 4⟩-⟨27, 6⟩
  s (isBinder := true) : Nat × Array (Array Nat) @ ⟨27, 8⟩-⟨27, 9⟩
  Array.push s.snd[1]! s.fst : Array Nat @ ⟨28, 2⟩-⟨28, 18⟩ @ Lean.Elab.Term.elabApp
    s.snd[1]! : Array Nat @ ⟨28, 2⟩-⟨28, 9⟩ @ «_aux_Init_Util___macroRules_term__[_]_!_1»
      Macro expansion
      s.2[1]!
      ===>
      getElem!✝ s.2 1
        s.snd[1]! : Array Nat @ ⟨28, 2⟩†-⟨28, 7⟩ @ Lean.Elab.Term.elabApp
          [.] `getElem!._@.infoTree._hyg.139 : none @ ⟨28, 2⟩†-⟨28, 9⟩†
          @getElem! : {Cont Idx Elem : Type} →
            {Dom : Cont → Idx → Prop} →
              [inst : GetElem Cont Idx Elem Dom] →
                [inst : Inhabited Elem] →
                  (xs : Cont) → (i : Idx) → [inst : Decidable (Dom xs i)] → Elem @ ⟨28, 2⟩†-⟨28, 9⟩†
          s.snd : Array (Array Nat) @ ⟨28, 2⟩-⟨28, 5⟩ @ Lean.Elab.Term.elabProj
            [.] `s : some ?_uniq @ ⟨28, 2⟩-⟨28, 3⟩
            s : Nat × Array (Array Nat) @ ⟨28, 2⟩-⟨28, 3⟩
            @Prod.snd : {α β : Type} → α × β → β @ ⟨28, 4⟩-⟨28, 5⟩
          1 : Nat @ ⟨28, 6⟩-⟨28, 7⟩ @ Lean.Elab.Term.elabNumLit
    [.] s.snd[1]! : Array Nat @ ⟨28, 2⟩-⟨28, 9⟩ : some Array.{0} Nat
    @Array.push : {α : Type} → Array α → α → Array α @ ⟨28, 10⟩-⟨28, 14⟩
    s.fst : Nat @ ⟨28, 15⟩-⟨28, 18⟩ @ Lean.Elab.Term.elabProj
      [.] `s : some ?_uniq @ ⟨28, 15⟩-⟨28, 16⟩
      s : Nat × Array (Array Nat) @ ⟨28, 15⟩-⟨28, 16⟩
      @Prod.fst : {α β : Type} → α × β → α @ ⟨28, 17⟩-⟨28, 18⟩
  f3 (isBinder := true) : Nat × Array (Array Nat) → Array Nat @ ⟨27, 4⟩-⟨27, 6⟩
[Elab.info] command @ ⟨30, 0⟩-⟨31, 20⟩ @ Lean.Elab.Command.elabDeclaration
  B : Type @ ⟨30, 14⟩-⟨30, 15⟩ @ Lean.Elab.Term.elabIdent
    [.] `B : some Sort.{?_uniq} @ ⟨30, 14⟩-⟨30, 15⟩
    B : Type @ ⟨30, 14⟩-⟨30, 15⟩
  arg (isBinder := true) : B @ ⟨30, 8⟩-⟨30, 11⟩
  Nat : Type @ ⟨30, 19⟩-⟨30, 22⟩ @ Lean.Elab.Term.elabIdent
    [.] `Nat : some Sort.{?_uniq} @ ⟨30, 19⟩-⟨30, 22⟩
    Nat : Type @ ⟨30, 19⟩-⟨30, 22⟩
  f4 (isBinder := true) : B → Nat @ ⟨30, 4⟩-⟨30, 6⟩
  arg (isBinder := true) : B @ ⟨30, 8⟩-⟨30, 11⟩
  A.val arg.pair.fst 0 : Nat @ ⟨31, 2⟩-⟨31, 20⟩ @ Lean.Elab.Term.elabApp
    [.] `arg.pair.fst.val : some Nat @ ⟨31, 2⟩-⟨31, 18⟩
    arg : B @ ⟨31, 2⟩-⟨31, 5⟩
    [.] arg : B @ ⟨31, 2⟩-⟨31, 18⟩ : some Nat
    B.pair : B → A × A @ ⟨31, 6⟩-⟨31, 10⟩
    [.] arg.pair : A × A @ ⟨31, 2⟩-⟨31, 18⟩ : some Nat
    @Prod.fst : {α β : Type} → α × β → α @ ⟨31, 11⟩-⟨31, 14⟩
    [.] arg.pair.fst : A @ ⟨31, 2⟩-⟨31, 18⟩ : some Nat
    A.val : A → Nat → Nat @ ⟨31, 15⟩-⟨31, 18⟩
    0 : Nat @ ⟨31, 19⟩-⟨31, 20⟩ @ Lean.Elab.Term.elabNumLit
  f4 (isBinder := true) : B → Nat @ ⟨30, 4⟩-⟨30, 6⟩
[Elab.info] command @ ⟨33, 0⟩-⟨35, 1⟩ @ Lean.Elab.Command.elabDeclaration
  Nat : Type @ ⟨33, 12⟩-⟨33, 15⟩ @ Lean.Elab.Term.elabIdent
    [.] `Nat : some Sort.{?_uniq} @ ⟨33, 12⟩-⟨33, 15⟩
    Nat : Type @ ⟨33, 12⟩-⟨33, 15⟩
  x (isBinder := true) : Nat @ ⟨33, 8⟩-⟨33, 9⟩
  B : Type @ ⟨33, 19⟩-⟨33, 20⟩ @ Lean.Elab.Term.elabIdent
    [.] `B : some Sort.{?_uniq} @ ⟨33, 19⟩-⟨33, 20⟩
    B : Type @ ⟨33, 19⟩-⟨33, 20⟩
  f5 (isBinder := true) : Nat → B @ ⟨33, 4⟩-⟨33, 6⟩
  x (isBinder := true) : Nat @ ⟨33, 8⟩-⟨33, 9⟩
  { pair := ({ val := id }, { val := id }) } : B @ ⟨33, 24⟩-⟨35, 1⟩ @ Lean.Elab.Term.StructInst.elabStructInst
    ({ val := id }, { val := id }) : A × A @ ⟨34, 10⟩-⟨34, 40⟩ @ Lean.Elab.Term.expandParen
      Macro expansion
      ({ val := id }, { val := id })
      ===>
      Prod.mk✝ { val := id } { val := id }
        ({ val := id }, { val := id }) : A × A @ ⟨34, 10⟩†-⟨34, 39⟩ @ Lean.Elab.Term.elabApp
          [.] `Prod.mk._@.infoTree._hyg.156 : some Prod.{0 0} A A @ ⟨34, 10⟩†-⟨34, 40⟩†
          @Prod.mk : {α β : Type} → α → β → α × β @ ⟨34, 10⟩†-⟨34, 40⟩†
          { val := id } : A @ ⟨34, 11⟩-⟨34, 24⟩ @ Lean.Elab.Term.StructInst.elabStructInst
            id : Nat → Nat @ ⟨34, 20⟩-⟨34, 22⟩ @ Lean.Elab.Term.elabIdent
              [.] `id : some Nat -> Nat @ ⟨34, 20⟩-⟨34, 22⟩
              @id : {α : Type} → α → α @ ⟨34, 20⟩-⟨34, 22⟩
            val : Nat → Nat := id @ ⟨34, 13⟩-⟨34, 16⟩
          { val := id } : A @ ⟨34, 26⟩-⟨34, 39⟩ @ Lean.Elab.Term.StructInst.elabStructInst
            id : Nat → Nat @ ⟨34, 35⟩-⟨34, 37⟩ @ Lean.Elab.Term.elabIdent
              [.] `id : some Nat -> Nat @ ⟨34, 35⟩-⟨34, 37⟩
              @id : {α : Type} → α → α @ ⟨34, 35⟩-⟨34, 37⟩
            val : Nat → Nat := id @ ⟨34, 28⟩-⟨34, 31⟩
    pair : A × A := ({ val := id }, { val := id }) @ ⟨34, 2⟩-⟨34, 6⟩
  f5 (isBinder := true) : Nat → B @ ⟨33, 4⟩-⟨33, 6⟩
def Nat.xor : Nat → Nat → Nat :=
bitwise bne
[Elab.info] command @ ⟨37, 0⟩-⟨38, 10⟩ @ Lean.Elab.Command.expandInCmd
  Macro expansion
  open Nat in #print xor
  ===>
  failed to pretty print term (use 'set_option pp.rawOnError true' for raw representation)
    command @ ⟨37, 0⟩†-⟨38, 10⟩† @ Lean.Elab.Command.elabSection
    command @ ⟨37, 0⟩-⟨37, 8⟩ @ Lean.Elab.Command.elabOpen
    command @ ⟨38, 0⟩-⟨38, 10⟩ @ Lean.Elab.Command.elabPrint
      [.] `xor : none @ ⟨38, 7⟩-⟨38, 10⟩
      xor : Nat → Nat → Nat @ ⟨38, 7⟩-⟨38, 10⟩
    command @ ⟨37, 0⟩†-⟨38, 10⟩† @ Lean.Elab.Command.elabEnd
infoTree.lean:41:0: error: expected identifier or term
[Elab.info] command @ ⟨39, 0⟩-⟨39, 30⟩ @ Lean.Elab.Command.elabDeclaration
  Inhabited Nat : Type @ ⟨39, 11⟩-⟨39, 24⟩ @ Lean.Elab.Term.elabApp
    [.] `Inhabited : some Sort.{?_uniq} @ ⟨39, 11⟩-⟨39, 20⟩
    Inhabited : Type → Type @ ⟨39, 11⟩-⟨39, 20⟩
    Nat : Type @ ⟨39, 21⟩-⟨39, 24⟩ @ Lean.Elab.Term.elabIdent
      [.] `Nat : some Sort.{?_uniq} @ ⟨39, 21⟩-⟨39, 24⟩
      Nat : Type @ ⟨39, 21⟩-⟨39, 24⟩
  instInhabitedNat_1 (isBinder := true) : Inhabited Nat @ ⟨39, 0⟩†-⟨39, 30⟩†
  instInhabitedNat_1 (isBinder := true) : Inhabited Nat @ ⟨39, 0⟩-⟨39, 8⟩
infoTree.lean:44:0: error: expected stx
[Elab.info] command @ ⟨41, 0⟩-⟨41, 5⟩ @ no_elab
[Elab.info] command @ ⟨44, 0⟩-⟨44, 22⟩ @ Lean.Elab.Command.elabSetOption
  [.] (Command.set_option "set_option" `pp.raw) @ ⟨44, 0⟩-⟨44, 17⟩
[Elab.info] command @ ⟨45, 0⟩-⟨47, 8⟩ @ Lean.Elab.Command.elabDeclaration
  Nat : Type @ ⟨45, 14⟩-⟨45, 17⟩ @ Lean.Elab.Term.elabIdent
    [.] `Nat : some Sort.{?_uniq} @ ⟨45, 14⟩-⟨45, 17⟩
    Nat : Type @ ⟨45, 14⟩-⟨45, 17⟩
  _uniq.1182 (isBinder := true) : Nat @ ⟨45, 8⟩-⟨45, 9⟩
  Nat : Type @ ⟨45, 14⟩-⟨45, 17⟩ @ Lean.Elab.Term.elabIdent
    [.] `Nat : some Sort.{?_uniq} @ ⟨45, 14⟩-⟨45, 17⟩
    Nat : Type @ ⟨45, 14⟩-⟨45, 17⟩
  _uniq.1184 (isBinder := true) : Nat @ ⟨45, 10⟩-⟨45, 11⟩
  Eq.{1} Nat _uniq.1182 _uniq.1182 : Prop @ ⟨45, 21⟩-⟨45, 26⟩ @ «_aux_Init_Notation___macroRules_term_=__2»
    Macro expansion
    («term_=_» `x "=" `x)
    ===>
    (Term.binrel "binrel%" `Eq._@.infoTree._hyg.182 `x `x)
      Eq.{1} Nat _uniq.1182 _uniq.1182 : Prop @ ⟨45, 21⟩†-⟨45, 26⟩ @ Lean.Elab.Term.BinOp.elabBinRel
        [.] `Eq._@.infoTree._hyg.182 : none @ ⟨45, 21⟩†-⟨45, 26⟩†
        _uniq.1182 : Nat @ ⟨45, 21⟩-⟨45, 22⟩ @ Lean.Elab.Term.elabIdent
          [.] `x : none @ ⟨45, 21⟩-⟨45, 22⟩
          _uniq.1182 : Nat @ ⟨45, 21⟩-⟨45, 22⟩
        _uniq.1182 : Nat @ ⟨45, 25⟩-⟨45, 26⟩ @ Lean.Elab.Term.elabIdent
          [.] `x : none @ ⟨45, 25⟩-⟨45, 26⟩
          _uniq.1182 : Nat @ ⟨45, 25⟩-⟨45, 26⟩
  _uniq.1188 (isBinder := true) : forall (x : Nat), Nat -> (Eq.{1} Nat x x) @ ⟨45, 4⟩-⟨45, 6⟩
  _uniq.1189 (isBinder := true) : Nat @ ⟨45, 8⟩-⟨45, 9⟩
  _uniq.1190 (isBinder := true) : Nat @ ⟨45, 10⟩-⟨45, 11⟩
  (fun (f7 : forall (x : Nat), Nat -> (Eq.{1} Nat x x)) => [mdata _recApp: f7 _uniq.1189 _uniq.1190]) f6.f7 : Eq.{1} Nat _uniq.1189 _uniq.1189 @ ⟨46, 2⟩-⟨47, 8⟩ @ Lean.Elab.Term.elabLetRec
    Nat : Type @ ⟨46, 20⟩-⟨46, 23⟩ @ Lean.Elab.Term.elabIdent
      [.] `Nat : some Sort.{?_uniq} @ ⟨46, 20⟩-⟨46, 23⟩
      Nat : Type @ ⟨46, 20⟩-⟨46, 23⟩
    _uniq.1192 (isBinder := true) : Nat @ ⟨46, 14⟩-⟨46, 15⟩
    Nat : Type @ ⟨46, 20⟩-⟨46, 23⟩ @ Lean.Elab.Term.elabIdent
      [.] `Nat : some Sort.{?_uniq} @ ⟨46, 20⟩-⟨46, 23⟩
      Nat : Type @ ⟨46, 20⟩-⟨46, 23⟩
    _uniq.1194 (isBinder := true) : Nat @ ⟨46, 16⟩-⟨46, 17⟩
    Eq.{1} Nat _uniq.1192 _uniq.1192 : Prop @ ⟨46, 27⟩-⟨46, 32⟩ @ «_aux_Init_Notation___macroRules_term_=__2»
      Macro expansion
      («term_=_» `x "=" `x)
      ===>
      (Term.binrel "binrel%" `Eq._@.infoTree._hyg.190 `x `x)
        Eq.{1} Nat _uniq.1192 _uniq.1192 : Prop @ ⟨46, 27⟩†-⟨46, 32⟩ @ Lean.Elab.Term.BinOp.elabBinRel
          [.] `Eq._@.infoTree._hyg.190 : none @ ⟨46, 27⟩†-⟨46, 32⟩†
          _uniq.1192 : Nat @ ⟨46, 27⟩-⟨46, 28⟩ @ Lean.Elab.Term.elabIdent
            [.] `x : none @ ⟨46, 27⟩-⟨46, 28⟩
            _uniq.1192 : Nat @ ⟨46, 27⟩-⟨46, 28⟩
          _uniq.1192 : Nat @ ⟨46, 31⟩-⟨46, 32⟩ @ Lean.Elab.Term.elabIdent
            [.] `x : none @ ⟨46, 31⟩-⟨46, 32⟩
            _uniq.1192 : Nat @ ⟨46, 31⟩-⟨46, 32⟩
    _uniq.1199 (isBinder := true) : forall (x : Nat), Nat -> (Eq.{1} Nat x x) @ ⟨46, 10⟩-⟨46, 12⟩
    _uniq.1200 (isBinder := true) : Nat @ ⟨46, 14⟩-⟨46, 15⟩
    _uniq.1201 (isBinder := true) : Nat @ ⟨46, 16⟩-⟨46, 17⟩
    Eq.refl.{1} Nat _uniq.1200 : Eq.{1} Nat _uniq.1200 _uniq.1200 @ ⟨46, 36⟩-⟨46, 45⟩ @ Lean.Elab.Term.elabApp
      [.] `Eq.refl : some Eq.{?_uniq} Nat _uniq.1200 _uniq.1200 @ ⟨46, 36⟩-⟨46, 43⟩
      Eq.refl.{1} : forall {α : Type} (a : α), Eq.{1} α a a @ ⟨46, 36⟩-⟨46, 43⟩
      _uniq.1200 : Nat @ ⟨46, 44⟩-⟨46, 45⟩ @ Lean.Elab.Term.elabIdent
        [.] `x : some ?_uniq @ ⟨46, 44⟩-⟨46, 45⟩
        _uniq.1200 : Nat @ ⟨46, 44⟩-⟨46, 45⟩
    [mdata _recApp: _uniq.1199 _uniq.1189 _uniq.1190] : Eq.{1} Nat _uniq.1189 _uniq.1189 @ ⟨47, 2⟩-⟨47, 8⟩ @ Lean.Elab.Term.elabApp
      [.] `f7 : some Eq.{1} Nat _uniq.1189 _uniq.1189 @ ⟨47, 2⟩-⟨47, 4⟩
      _uniq.1199 : forall (x : Nat), Nat -> (Eq.{1} Nat x x) @ ⟨47, 2⟩-⟨47, 4⟩
      _uniq.1189 : Nat @ ⟨47, 5⟩-⟨47, 6⟩ @ Lean.Elab.Term.elabIdent
        [.] `x : some Nat @ ⟨47, 5⟩-⟨47, 6⟩
        _uniq.1189 : Nat @ ⟨47, 5⟩-⟨47, 6⟩
      _uniq.1190 : Nat @ ⟨47, 7⟩-⟨47, 8⟩ @ Lean.Elab.Term.elabIdent
        [.] `y : some Nat @ ⟨47, 7⟩-⟨47, 8⟩
        _uniq.1190 : Nat @ ⟨47, 7⟩-⟨47, 8⟩
  f6.f7 (isBinder := true) : forall (x : Nat), Nat -> (Eq.{1} Nat x x) @ ⟨46, 10⟩-⟨46, 12⟩
  f6 (isBinder := true) : forall (x : Nat), Nat -> (Eq.{1} Nat x x) @ ⟨45, 4⟩-⟨45, 6⟩
[Elab.info] command @ ⟨50, 0⟩-⟨50, 32⟩ @ Lean.Elab.Command.elabDeclaration
  B : Type @ ⟨50, 12⟩-⟨50, 13⟩ @ Lean.Elab.Term.elabIdent
    [.] `B : some Sort.{?_uniq} @ ⟨50, 12⟩-⟨50, 13⟩
    B : Type @ ⟨50, 12⟩-⟨50, 13⟩
  _uniq.1224 (isBinder := true) : B @ ⟨50, 8⟩-⟨50, 9⟩
  B : Type @ ⟨50, 17⟩-⟨50, 18⟩ @ Lean.Elab.Term.elabIdent
    [.] `B : some Sort.{?_uniq} @ ⟨50, 17⟩-⟨50, 18⟩
    B : Type @ ⟨50, 17⟩-⟨50, 18⟩
  _uniq.1226 (isBinder := true) : B -> B @ ⟨50, 4⟩-⟨50, 6⟩
  _uniq.1227 (isBinder := true) : B @ ⟨50, 8⟩-⟨50, 9⟩
  B.mk (B.pair _uniq.1227) : B @ ⟨50, 22⟩-⟨50, 32⟩ @ Lean.Elab.Term.StructInst.elabStructInst
    _uniq.1227 : B @ ⟨50, 24⟩-⟨50, 25⟩
    B.pair _uniq.1227 : Prod.{0 0} A A @ ⟨50, 24⟩-⟨50, 25⟩† @ Lean.Elab.Term.elabProj
      [.] `b : some Prod.{0 0} A A @ ⟨50, 24⟩-⟨50, 25⟩
      _uniq.1227 : B @ ⟨50, 24⟩-⟨50, 25⟩
      [.] _uniq.1227 : B @ ⟨50, 24⟩-⟨50, 25⟩ : some Prod.{0 0} A A
      B.pair : B -> (Prod.{0 0} A A) @ ⟨50, 24⟩†-⟨50, 25⟩†
    pair : Prod.{0 0} A A := B.pair _uniq.1227 @ ⟨50, 22⟩†-⟨50, 32⟩
  f7 (isBinder := true) : B -> B @ ⟨50, 4⟩-⟨50, 6⟩

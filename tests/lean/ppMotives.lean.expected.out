protected def Nat.add : Nat → Nat → Nat :=
fun x x_1 =>
  Nat.brecOn x_1
    (fun x f x_2 =>
      (match x_2, x with 
        | a, Nat.zero => fun x => a
        | a, Nat.succ b => fun x => Nat.succ (PProd.fst x.fst a))
        f)
    x
protected def Nat.add : Nat → Nat → Nat :=
fun x x_1 =>
  Nat.brecOn (motive := fun x => Nat → Nat) x_1
    (fun x f x_2 =>
      (match x_2, x : (x x : Nat) → Nat.below (motive := fun x => Nat → Nat) x → Nat with 
        | a, Nat.zero => fun x => a
        | a, Nat.succ b => fun x => Nat.succ (PProd.fst x.fst a))
        f)
    x
theorem ex.{u} : ∀ {α β : Sort u} (h : α = β) (a : α), HEq (cast h a) a :=
fun x x_1 x_2 x_3 =>
  match x, x_1, x_2, x_3 with 
  | α, .(α), Eq.refl α, a => HEq.refl a
theorem ex.{u} : ∀ {α β : Sort u} (h : α = β) (a : α), HEq (cast h a) a :=
fun x x_1 x_2 x_3 =>
  match x, x_1, x_2, x_3 : ∀ (x x_4 : Sort u) (x_5 : x = x_4) (x_6 : x), HEq (cast x_5 x_6) x_6 with 
  | α, .(α), Eq.refl α, a => HEq.refl a
def fact : Nat → Nat :=
fun n => Nat.recOn n 1 fun n acc => (n + 1) * acc
def fact : Nat → Nat :=
fun n => Nat.recOn (motive := fun n => Nat) n 1 fun n acc => (n + 1) * acc

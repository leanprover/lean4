alternative : (Type → Type) → Type
applicative : (Type → Type) → Type
decidable : Prop → Type₁
functor : (Type → Type) → Type
has_add : Type → Type
has_append : Type → Type
has_div : Type → Type
has_dvd : Type → Type
has_inv : Type → Type
has_le : Type → Type
has_lt : Type → Type
has_mod : Type → Type
has_mul : Type → Type
has_neg : Type → Type
has_one : Type → Type
has_ordering : Type → Type
has_sub : Type → Type
has_to_format : Type → Type
has_to_qexpr : Type → Type
has_to_string : Type → Type
has_to_tactic_format : Type → Type
has_zero : Type → Type
inhabited : Type → Type
measurable : Type → Type
monad : (Type → Type) → Type
nonempty : Type → Prop
point : Type → Type → Type
setoid : Type → Type
subsingleton : Type → Prop
well_founded : Π {A}, (A → A → Prop) → Prop
alternative : (Type → Type) → Type
applicative : (Type → Type) → Type
decidable : Prop → Type₁
functor : (Type → Type) → Type
has_add : Type → Type
has_append : Type → Type
has_div : Type → Type
has_dvd : Type → Type
has_inv : Type → Type
has_le : Type → Type
has_lt : Type → Type
has_mod : Type → Type
has_mul : Type → Type
has_neg : Type → Type
has_one : Type → Type
has_ordering : Type → Type
has_sub : Type → Type
has_to_format : Type → Type
has_to_qexpr : Type → Type
has_to_string : Type → Type
has_to_tactic_format : Type → Type
has_zero : Type → Type
inhabited : Type → Type
measurable : Type → Type
monad : (Type → Type) → Type
nonempty : Type → Prop
point : Type → Type → Type
setoid : Type → Type
subsingleton : Type → Prop
well_founded : Π {A}, (A → A → Prop) → Prop
